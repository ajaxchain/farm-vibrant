import {
  __commonJS
} from "./chunk-DFKQJ226.js";

// node_modules/web3/lib/web3/jsonrpc.js
var require_jsonrpc = __commonJS({
  "node_modules/web3/lib/web3/jsonrpc.js"(exports, module) {
    var Jsonrpc = {
      messageId: 0
    };
    Jsonrpc.toPayload = function(method, params) {
      if (!method)
        console.error("jsonrpc method should be specified!");
      Jsonrpc.messageId++;
      return {
        jsonrpc: "2.0",
        id: Jsonrpc.messageId,
        method,
        params: params || []
      };
    };
    Jsonrpc.isValidResponse = function(response) {
      return Array.isArray(response) ? response.every(validateSingleMessage) : validateSingleMessage(response);
      function validateSingleMessage(message) {
        return !!message && !message.error && message.jsonrpc === "2.0" && typeof message.id === "number" && message.result !== void 0;
      }
    };
    Jsonrpc.toBatchPayload = function(messages) {
      return messages.map(function(message) {
        return Jsonrpc.toPayload(message.method, message.params);
      });
    };
    module.exports = Jsonrpc;
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports, module) {
    (function(global2) {
      "use strict";
      var BigNumber, crypto, parseNumeric, isNumeric = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, notBool = " not a boolean or binary digit", roundingMode = "rounding mode", tooManyDigits = "number type has more than 15 significant digits", ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function another(configObj) {
        var div, id = 0, P = BigNumber2.prototype, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, ERRORS = true, isValidInt = intValidatorWithErrors, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 100, FORMAT = {
          decimalSeparator: ".",
          groupSeparator: ",",
          groupSize: 3,
          secondaryGroupSize: 0,
          fractionGroupSeparator: "Â ",
          // non-breaking space
          fractionGroupSize: 0
        };
        function BigNumber2(n, b) {
          var c, e, i, num, len, str, x = this;
          if (!(x instanceof BigNumber2)) {
            if (ERRORS)
              raise(26, "constructor call without new", n);
            return new BigNumber2(n, b);
          }
          if (b == null || !isValidInt(b, 2, 64, id, "base")) {
            if (n instanceof BigNumber2) {
              x.s = n.s;
              x.e = n.e;
              x.c = (n = n.c) ? n.slice() : n;
              id = 0;
              return;
            }
            if ((num = typeof n == "number") && n * 0 == 0) {
              x.s = 1 / n < 0 ? (n = -n, -1) : 1;
              if (n === ~~n) {
                for (e = 0, i = n; i >= 10; i /= 10, e++)
                  ;
                x.e = e;
                x.c = [n];
                id = 0;
                return;
              }
              str = n + "";
            } else {
              if (!isNumeric.test(str = n + ""))
                return parseNumeric(x, str, num);
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
          } else {
            b = b | 0;
            str = n + "";
            if (b == 10) {
              x = new BigNumber2(n instanceof BigNumber2 ? n : str);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            if ((num = typeof n == "number") && n * 0 != 0 || !new RegExp("^-?" + (c = "[" + ALPHABET.slice(0, b) + "]+") + "(?:\\." + c + ")?$", b < 37 ? "i" : "").test(str)) {
              return parseNumeric(x, str, num, b);
            }
            if (num) {
              x.s = 1 / n < 0 ? (str = str.slice(1), -1) : 1;
              if (ERRORS && str.replace(/^0\.0*|\./, "").length > 15) {
                raise(id, tooManyDigits, n);
              }
              num = false;
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            str = convertBase(str, 10, b, x.s);
          }
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          if ((i = str.search(/e/i)) > 0) {
            if (e < 0)
              e = i;
            e += +str.slice(i + 1);
            str = str.substring(0, i);
          } else if (e < 0) {
            e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++)
            ;
          for (len = str.length; str.charCodeAt(--len) === 48; )
            ;
          str = str.slice(i, len + 1);
          if (str) {
            len = str.length;
            if (num && ERRORS && len > 15)
              raise(id, tooManyDigits, x.s * n);
            e = e - i - 1;
            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0)
                i += LOG_BASE;
              if (i < len) {
                if (i)
                  x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                str = str.slice(i);
                i = LOG_BASE - str.length;
              } else {
                i -= len;
              }
              for (; i--; str += "0")
                ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
          id = 0;
        }
        BigNumber2.another = another;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = function() {
          var v, p, i = 0, r = {}, a = arguments, o = a[0], has = o && typeof o == "object" ? function() {
            if (o.hasOwnProperty(p))
              return (v = o[p]) != null;
          } : function() {
            if (a.length > i)
              return (v = a[i++]) != null;
          };
          if (has(p = "DECIMAL_PLACES") && isValidInt(v, 0, MAX, 2, p)) {
            DECIMAL_PLACES = v | 0;
          }
          r[p] = DECIMAL_PLACES;
          if (has(p = "ROUNDING_MODE") && isValidInt(v, 0, 8, 2, p)) {
            ROUNDING_MODE = v | 0;
          }
          r[p] = ROUNDING_MODE;
          if (has(p = "EXPONENTIAL_AT")) {
            if (isArray(v)) {
              if (isValidInt(v[0], -MAX, 0, 2, p) && isValidInt(v[1], 0, MAX, 2, p)) {
                TO_EXP_NEG = v[0] | 0;
                TO_EXP_POS = v[1] | 0;
              }
            } else if (isValidInt(v, -MAX, MAX, 2, p)) {
              TO_EXP_NEG = -(TO_EXP_POS = (v < 0 ? -v : v) | 0);
            }
          }
          r[p] = [TO_EXP_NEG, TO_EXP_POS];
          if (has(p = "RANGE")) {
            if (isArray(v)) {
              if (isValidInt(v[0], -MAX, -1, 2, p) && isValidInt(v[1], 1, MAX, 2, p)) {
                MIN_EXP = v[0] | 0;
                MAX_EXP = v[1] | 0;
              }
            } else if (isValidInt(v, -MAX, MAX, 2, p)) {
              if (v | 0)
                MIN_EXP = -(MAX_EXP = (v < 0 ? -v : v) | 0);
              else if (ERRORS)
                raise(2, p + " cannot be zero", v);
            }
          }
          r[p] = [MIN_EXP, MAX_EXP];
          if (has(p = "ERRORS")) {
            if (v === !!v || v === 1 || v === 0) {
              id = 0;
              isValidInt = (ERRORS = !!v) ? intValidatorWithErrors : intValidatorNoErrors;
            } else if (ERRORS) {
              raise(2, p + notBool, v);
            }
          }
          r[p] = ERRORS;
          if (has(p = "CRYPTO")) {
            if (v === !!v || v === 1 || v === 0) {
              CRYPTO = !!(v && crypto && typeof crypto == "object");
              if (v && !CRYPTO && ERRORS)
                raise(2, "crypto unavailable", crypto);
            } else if (ERRORS) {
              raise(2, p + notBool, v);
            }
          }
          r[p] = CRYPTO;
          if (has(p = "MODULO_MODE") && isValidInt(v, 0, 9, 2, p)) {
            MODULO_MODE = v | 0;
          }
          r[p] = MODULO_MODE;
          if (has(p = "POW_PRECISION") && isValidInt(v, 0, MAX, 2, p)) {
            POW_PRECISION = v | 0;
          }
          r[p] = POW_PRECISION;
          if (has(p = "FORMAT")) {
            if (typeof v == "object") {
              FORMAT = v;
            } else if (ERRORS) {
              raise(2, p + " not an object", v);
            }
          }
          r[p] = FORMAT;
          return r;
        };
        BigNumber2.max = function() {
          return maxOrMin(arguments, P.lt);
        };
        BigNumber2.min = function() {
          return maxOrMin(arguments, P.gt);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            dp = dp == null || !isValidInt(dp, 0, MAX, 14) ? DECIMAL_PLACES : dp | 0;
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto && crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto && crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else if (ERRORS) {
                raise(14, "crypto unavailable", crypto);
              }
            }
            if (!i) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15)
                  c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--)
              ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.shift(), e -= LOG_BASE)
                ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
                ;
              if (i < LOG_BASE)
                e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        function convertBase(str, baseOut, baseIn, sign) {
          var d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
          if (baseIn < 37)
            str = str.toLowerCase();
          if (i >= 0) {
            k = POW_PRECISION;
            POW_PRECISION = 0;
            str = str.replace(".", "");
            y = new BigNumber2(baseIn);
            x = y.pow(str.length - i);
            POW_PRECISION = k;
            y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e), 10, baseOut);
            y.e = y.c.length;
          }
          xc = toBaseOut(str, baseIn, baseOut);
          e = k = xc.length;
          for (; xc[--k] == 0; xc.pop())
            ;
          if (!xc[0])
            return "0";
          if (i < 0) {
            --e;
          } else {
            x.c = xc;
            x.e = e;
            x.s = sign;
            x = div(x, y, dp, rm, baseOut);
            xc = x.c;
            r = x.r;
            e = x.e;
          }
          d = e + dp + 1;
          i = xc[d];
          k = baseOut / 2;
          r = r || d < 0 || xc[d + 1] != null;
          r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
          if (d < 1 || !xc[0]) {
            str = r ? toFixedPoint("1", -dp) : "0";
          } else {
            xc.length = d;
            if (r) {
              for (--baseOut; ++xc[--d] > baseOut; ) {
                xc[d] = 0;
                if (!d) {
                  ++e;
                  xc.unshift(1);
                }
              }
            }
            for (k = xc.length; !xc[--k]; )
              ;
            for (i = 0, str = ""; i <= k; str += ALPHABET.charAt(xc[i++]))
              ;
            str = toFixedPoint(str, e);
          }
          return str;
        }
        div = function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry)
              x.unshift(carry);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.shift())
              ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return Â±0 if x is Â±0 or y is Â±Infinity, or return Â±Infinity as y is Â±0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++)
              ;
            if (yc[i] > (xc[i] || 0))
              e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0)
                ;
              yz = yc.slice();
              yz.unshift(0);
              yc0 = yc[0];
              if (yc[1] >= base / 2)
                yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base)
                      n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL)
                    prod.unshift(0);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0])
                qc.shift();
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
                ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, caller) {
          var c0, e, ne, len, str;
          rm = rm != null && isValidInt(rm, 0, 8, caller, roundingMode) ? rm | 0 : ROUNDING_MODE;
          if (!n.c)
            return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = caller == 19 || caller == 24 && ne <= TO_EXP_NEG ? toExponential(str, ne) : toFixedPoint(str, ne);
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (caller == 19 || caller == 24 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++)
                ;
              str = toExponential(str, e);
            } else {
              i -= ne;
              str = toFixedPoint(str, e);
              if (e + 1 > len) {
                if (--i > 0)
                  for (str += "."; i--; str += "0")
                    ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len)
                    str += ".";
                  for (; i--; str += "0")
                    ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, method) {
          var m, n, i = 0;
          if (isArray(args[0]))
            args = args[0];
          m = new BigNumber2(args[0]);
          for (; ++i < args.length; ) {
            n = new BigNumber2(args[i]);
            if (!n.s) {
              m = n;
              break;
            } else if (method.call(m, n)) {
              m = n;
            }
          }
          return m;
        }
        function intValidatorWithErrors(n, min, max, caller, name) {
          if (n < min || n > max || n != truncate(n)) {
            raise(caller, (name || "decimal places") + (n < min || n > max ? " out of range" : " not an integer"), n);
          }
          return true;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop())
            ;
          for (j = c[0]; j >= 10; j /= 10, i++)
            ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = function() {
          var basePrefix = /^(-?)0([xbo])/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+|^\s+|\s+$/g;
          return function(x, str, num, b) {
            var base, s = num ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!num) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s)
                  return new BigNumber2(s, base);
              }
              if (ERRORS)
                raise(id, "not a" + (b ? " base " + b : "") + " number", str);
              x.s = null;
            }
            x.c = x.e = null;
            id = 0;
          };
        }();
        function raise(caller, msg, val) {
          var error = new Error([
            "new BigNumber",
            // 0
            "cmp",
            // 1
            "config",
            // 2
            "div",
            // 3
            "divToInt",
            // 4
            "eq",
            // 5
            "gt",
            // 6
            "gte",
            // 7
            "lt",
            // 8
            "lte",
            // 9
            "minus",
            // 10
            "mod",
            // 11
            "plus",
            // 12
            "precision",
            // 13
            "random",
            // 14
            "round",
            // 15
            "shift",
            // 16
            "times",
            // 17
            "toDigits",
            // 18
            "toExponential",
            // 19
            "toFixed",
            // 20
            "toFormat",
            // 21
            "toFraction",
            // 22
            "pow",
            // 23
            "toPrecision",
            // 24
            "toString",
            // 25
            "BigNumber"
            // 26
          ][caller] + "() " + msg + ": " + val);
          error.name = "BigNumber Error";
          id = 0;
          throw error;
        }
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
                ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = n / pows10[d - j - 1] % 10 | 0;
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0))
                      ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++)
                    ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[ d - j - 1 ]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[sd % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                      ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++)
                      ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE)
                        xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE)
                      break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop())
                ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0)
            x.s = 1;
          return x;
        };
        P.ceil = function() {
          return round(new BigNumber2(this), this.e + 1, 2);
        };
        P.comparedTo = P.cmp = function(y, b) {
          id = 1;
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function() {
          var n, v, c = this.c;
          if (!c)
            return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v])
            for (; v % 10 == 0; v /= 10, n--)
              ;
          if (n < 0)
            n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          id = 3;
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.divToInt = function(y, b) {
          id = 4;
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.equals = P.eq = function(y, b) {
          id = 5;
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.floor = function() {
          return round(new BigNumber2(this), this.e + 1, 3);
        };
        P.greaterThan = P.gt = function(y, b) {
          id = 6;
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.greaterThanOrEqualTo = P.gte = function(y, b) {
          id = 7;
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isInteger = P.isInt = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = P.isNeg = function() {
          return this.s < 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.lessThan = P.lt = function(y, b) {
          id = 8;
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.lessThanOrEqualTo = P.lte = function(y, b) {
          id = 9;
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.minus = P.sub = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          id = 10;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0))
              ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy)
            t = xc, xc = yc, yc = t, y.s = -y.s;
          b = (j = yc.length) - (i = xc.length);
          if (b > 0)
            for (; b--; xc[i++] = 0)
              ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b)
                ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.shift(), --ye)
            ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          id = 11;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          return x.minus(q.times(y));
        };
        P.negated = P.neg = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = P.add = function(y, b) {
          var t, x = this, a = x.s;
          id = 12;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0])
              return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0))
              ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0)
            t = yc, yc = xc, xc = t, b = a;
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] %= BASE;
          }
          if (a) {
            xc.unshift(a);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(z) {
          var n, v, x = this, c = x.c;
          if (z != null && z !== !!z && z !== 1 && z !== 0) {
            if (ERRORS)
              raise(13, "argument" + notBool, z);
            if (z != !!z)
              z = null;
          }
          if (!c)
            return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--)
              ;
            for (v = c[0]; v >= 10; v /= 10, n++)
              ;
          }
          if (z && x.e + 1 > n)
            n = x.e + 1;
          return n;
        };
        P.round = function(dp, rm) {
          var n = new BigNumber2(this);
          if (dp == null || isValidInt(dp, 0, MAX, 15)) {
            round(n, ~~dp + this.e + 1, rm == null || !isValidInt(rm, 0, 8, 15, roundingMode) ? ROUNDING_MODE : rm | 0);
          }
          return n;
        };
        P.shift = function(k) {
          var n = this;
          return isValidInt(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 16, "argument") ? n.times("1e" + truncate(k)) : new BigNumber2(n.c && n.c[0] && (k < -MAX_SAFE_INTEGER || k > MAX_SAFE_INTEGER) ? n.s * (k < 0 ? 0 : 1 / 0) : n);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+x);
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0)
              n += "0";
            s = Math.sqrt(n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "1e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3)
              s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e)
                  --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.times = P.mul = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (id = 17, y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL)
            zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
          for (i = xcL + ycL, zc = []; i--; zc.push(0))
            ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.shift();
          }
          return normalise(y, zc, e);
        };
        P.toDigits = function(sd, rm) {
          var n = new BigNumber2(this);
          sd = sd == null || !isValidInt(sd, 1, MAX, 18, "precision") ? null : sd | 0;
          rm = rm == null || !isValidInt(rm, 0, 8, 18, roundingMode) ? ROUNDING_MODE : rm | 0;
          return sd ? round(n, sd, rm) : n;
        };
        P.toExponential = function(dp, rm) {
          return format(
            this,
            dp != null && isValidInt(dp, 0, MAX, 19) ? ~~dp + 1 : null,
            rm,
            19
          );
        };
        P.toFixed = function(dp, rm) {
          return format(this, dp != null && isValidInt(dp, 0, MAX, 20) ? ~~dp + this.e + 1 : null, rm, 20);
        };
        P.toFormat = function(dp, rm) {
          var str = format(this, dp != null && isValidInt(dp, 0, MAX, 21) ? ~~dp + this.e + 1 : null, rm, 21);
          if (this.c) {
            var i, arr = str.split("."), g1 = +FORMAT.groupSize, g2 = +FORMAT.secondaryGroupSize, groupSeparator = FORMAT.groupSeparator, intPart = arr[0], fractionPart = arr[1], isNeg = this.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2)
              i = g1, g1 = g2, g2 = i, len -= i;
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1) {
                intPart += groupSeparator + intDigits.substr(i, g1);
              }
              if (g2 > 0)
                intPart += groupSeparator + intDigits.slice(i);
              if (isNeg)
                intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + FORMAT.decimalSeparator + ((g2 = +FORMAT.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + FORMAT.fractionGroupSeparator
            ) : fractionPart) : intPart;
          }
          return str;
        };
        P.toFraction = function(md) {
          var arr, d0, d2, e, exp, n, n0, q, s, k = ERRORS, x = this, xc = x.c, d = new BigNumber2(ONE), n1 = d0 = new BigNumber2(ONE), d1 = n0 = new BigNumber2(ONE);
          if (md != null) {
            ERRORS = false;
            n = new BigNumber2(md);
            ERRORS = k;
            if (!(k = n.isInt()) || n.lt(ONE)) {
              if (ERRORS) {
                raise(
                  22,
                  "max denominator " + (k ? "out of range" : "not an integer"),
                  md
                );
              }
              md = !k && n.c && round(n, n.e + 1, 1).gte(ONE) ? n : null;
            }
          }
          if (!xc)
            return x.toString();
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.cmp(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.cmp(md) == 1)
              break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e *= 2;
          arr = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().cmp(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1.toString(), d1.toString()] : [n0.toString(), d0.toString()];
          MAX_EXP = exp;
          return arr;
        };
        P.toNumber = function() {
          var x = this;
          return +x || (x.s ? x.s * 0 : NaN);
        };
        P.toPower = P.pow = function(n) {
          var k, y, i = mathfloor(n < 0 ? -n : +n), x = this;
          if (!isValidInt(n, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 23, "exponent") && (!isFinite(n) || i > MAX_SAFE_INTEGER && (n /= 0) || parseFloat(n) != n && !(n = NaN))) {
            return new BigNumber2(Math.pow(+x, n));
          }
          k = POW_PRECISION ? mathceil(POW_PRECISION / LOG_BASE + 2) : 0;
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (i % 2) {
              y = y.times(x);
              if (!y.c)
                break;
              if (k && y.c.length > k)
                y.c.length = k;
            }
            i = mathfloor(i / 2);
            if (!i)
              break;
            x = x.times(x);
            if (k && x.c && x.c.length > k)
              x.c.length = k;
          }
          if (n < 0)
            y = ONE.div(y);
          return k ? round(y, POW_PRECISION, ROUNDING_MODE) : y;
        };
        P.toPrecision = function(sd, rm) {
          return format(this, sd != null && isValidInt(sd, 1, MAX, 24, "precision") ? sd | 0 : null, rm, 24);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0)
                str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            str = coeffToString(n.c);
            if (b == null || !isValidInt(b, 2, 64, 25, "base")) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e);
            } else {
              str = convertBase(toFixedPoint(str, e), b | 0, 10, s);
            }
            if (s < 0 && n.c[0])
              str = "-" + str;
          }
          return str;
        };
        P.truncated = P.trunc = function() {
          return round(new BigNumber2(this), this.e + 1, 1);
        };
        P.valueOf = P.toJSON = function() {
          return this.toString();
        };
        if (configObj != null)
          BigNumber2.config(configObj);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s)
            ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; )
          ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j)
          return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b)
          return a ? b ? 0 : -j : i;
        if (i != j)
          return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc)
          return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b)
          return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++)
          if (xc[i] != yc[i])
            return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intValidatorNoErrors(n, min, max) {
        return (n = truncate(n)) >= min && n <= max;
      }
      function isArray(obj) {
        return Object.prototype.toString.call(obj) == "[object Array]";
      }
      function toBaseOut(str, baseIn, baseOut) {
        var j, arr = [0], arrL, i = 0, len = str.length;
        for (; i < len; ) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
            ;
          arr[j = 0] += ALPHABET.indexOf(str.charAt(i++));
          for (; j < arr.length; j++) {
            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null)
                arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }
        return arr.reverse();
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e) {
        var len, z;
        if (e < 0) {
          for (z = "0."; ++e; z += "0")
            ;
          str = z + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (z = "0", e -= len; --e; z += "0")
              ;
            str += z;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      function truncate(n) {
        n = parseFloat(n);
        return n < 0 ? mathceil(n) : mathfloor(n);
      }
      BigNumber = another();
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = BigNumber;
        if (!crypto)
          try {
            crypto = require_crypto();
          } catch (e) {
          }
      } else {
        global2.BigNumber = BigNumber;
      }
    })(exports);
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var create = Object.create || function() {
          function F() {
          }
          ;
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var i = 0; i < thatSigBytes; i += 4) {
                thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            var r = function(m_w) {
              var m_w = m_w;
              var m_z = 987654321;
              var mask = 4294967295;
              return function() {
                m_z = 36969 * (m_z & 65535) + (m_z >> 16) & mask;
                m_w = 18e3 * (m_w & 65535) + (m_w >> 16) & mask;
                var result = (m_z << 16) + m_w & mask;
                result /= 4294967296;
                result += 0.5;
                return result * (Math2.random() > 0.5 ? 1 : -1);
              };
            };
            for (var i = 0, rcache; i < nBytes; i += 4) {
              var _r = r((rcache || Math2.random()) * 4294967296);
              rcache = _r() * 987654071;
              words.push(_r() * 4294967296 | 0);
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              var processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/x64-core.js
var require_x64_core = __commonJS({
  "node_modules/crypto-js/x64-core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C.x64 = {};
        var X64Word = C_x64.Word = Base.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        });
        var X64WordArray = C_x64.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i = 0; i < x64WordsLength; i++) {
              var x64Word = x64Words[i];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            var words = clone.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i = 0; i < wordsLength; i++) {
              words[i] = words[i].clone();
            }
            return clone;
          }
        });
      })();
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/lib-typedarrays.js
var require_lib_typedarrays = __commonJS({
  "node_modules/crypto-js/lib-typedarrays.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i = 0; i < typedArrayByteLength; i++) {
              words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS.lib.WordArray;
    });
  }
});

// node_modules/crypto-js/enc-utf16.js
var require_enc_utf16 = __commonJS({
  "node_modules/crypto-js/enc-utf16.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS.enc.Utf16;
    });
  }
});

// node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "node_modules/crypto-js/enc-base64.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64 = C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              words[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  }
});

// node_modules/crypto-js/md5.js
var require_md5 = __commonJS({
  "node_modules/crypto-js/md5.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d, M_offset_0, 6, T[48]);
            d = II(d, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6, T[52]);
            d = II(d, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d, M_offset_8, 6, T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4, 6, T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d, a, M_offset_9, 21, T[63]);
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function GG(a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  }
});

// node_modules/crypto-js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/crypto-js/sha1.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            for (var i = 0; i < 80; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = n << 1 | n >>> 31;
              }
              var t = (a << 5 | a >>> 27) + e + W[i];
              if (i < 20) {
                t += (b & c | ~b & d) + 1518500249;
              } else if (i < 40) {
                t += (b ^ c ^ d) + 1859775393;
              } else if (i < 60) {
                t += (b & c | b & d | c & d) - 1894007588;
              } else {
                t += (b ^ c ^ d) - 899497514;
              }
              e = d;
              d = c;
              c = b << 30 | b >>> 2;
              b = a;
              a = t;
            }
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS.SHA1;
    });
  }
});

// node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/crypto-js/sha256.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n2) {
            var sqrtN = Math2.sqrt(n2);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n2 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n2) {
            return (n2 - (n2 | 0)) * 4294967296 | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H2 = this._hash.words;
            var a = H2[0];
            var b = H2[1];
            var c = H2[2];
            var d = H2[3];
            var e = H2[4];
            var f = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f;
              f = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b | 0;
            H2[2] = H2[2] + c | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e | 0;
            H2[5] = H2[5] + f | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// node_modules/crypto-js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/crypto-js/sha224.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha256());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash = SHA256._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }
        });
        C.SHA224 = SHA256._createHelper(SHA224);
        C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS.SHA224;
    });
  }
});

// node_modules/crypto-js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/crypto-js/sha512.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W = [];
        (function() {
          for (var i = 0; i < 80; i++) {
            W[i] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i = 0; i < 80; i++) {
              var Wi = W[i];
              if (i < 16) {
                var Wih = Wi.high = M[offset + i * 2] | 0;
                var Wil = Wi.low = M[offset + i * 2 + 1] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W[i - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W[i - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W[i - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                var Wil = gamma0l + Wi7l;
                var Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                var Wil = Wil + gamma1l;
                var Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                var Wil = Wil + Wi16l;
                var Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K[i];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H2.low = H2l + cl;
            H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl;
            H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          },
          blockSize: 1024 / 32
        });
        C.SHA512 = Hasher._createHelper(SHA512);
        C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS.SHA512;
    });
  }
});

// node_modules/crypto-js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/crypto-js/sha384.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_sha512());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./sha512"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash = SHA512._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }
        });
        C.SHA384 = SHA512._createHelper(SHA384);
        C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS.SHA384;
    });
  }
});

// node_modules/crypto-js/sha3.js
var require_sha3 = __commonJS({
  "node_modules/crypto-js/sha3.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var C_algo = C.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x = 1, y = 0;
          for (var t = 0; t < 24; t++) {
            RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
            var newX = y % 5;
            var newY = (2 * x + 3 * y) % 5;
            x = newX;
            y = newY;
          }
          for (var x = 0; x < 5; x++) {
            for (var y = 0; y < 5; y++) {
              PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i = 0; i < 24; i++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T = [];
        (function() {
          for (var i = 0; i < 25; i++) {
            T[i] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state = this._state = [];
            for (var i = 0; i < 25; i++) {
              state[i] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i = 0; i < nBlockSizeLanes; i++) {
              var M2i = M[offset + 2 * i];
              var M2i1 = M[offset + 2 * i + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state[i];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x = 0; x < 5; x++) {
                var tMsw = 0, tLsw = 0;
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T[x];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x = 0; x < 5; x++) {
                var Tx4 = T[(x + 4) % 5];
                var Tx1 = T[(x + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  var tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  var tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  var tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  var tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x = 0; x < 5; x++) {
                for (var y = 0; y < 5; y++) {
                  var laneIndex = x + 5 * y;
                  var lane = state[laneIndex];
                  var TLane = T[laneIndex];
                  var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                  var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
              ;
            }
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i = 0; i < outputLengthLanes; i++) {
              var lane = state[i];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            var state = clone._state = this._state.slice(0);
            for (var i = 0; i < 25; i++) {
              state[i] = state[i].clone();
            }
            return clone;
          }
        });
        C.SHA3 = Hasher._createHelper(SHA3);
        C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS.SHA3;
    });
  }
});

// node_modules/crypto-js/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/crypto-js/ripemd160.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t;
            for (var i = 0; i < 80; i += 1) {
              t = al + M[offset + zl[i]] | 0;
              if (i < 16) {
                t += f1(bl, cl, dl) + hl[0];
              } else if (i < 32) {
                t += f2(bl, cl, dl) + hl[1];
              } else if (i < 48) {
                t += f3(bl, cl, dl) + hl[2];
              } else if (i < 64) {
                t += f4(bl, cl, dl) + hl[3];
              } else {
                t += f5(bl, cl, dl) + hl[4];
              }
              t = t | 0;
              t = rotl(t, sl[i]);
              t = t + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t;
              t = ar + M[offset + zr[i]] | 0;
              if (i < 16) {
                t += f5(br, cr, dr) + hr[0];
              } else if (i < 32) {
                t += f4(br, cr, dr) + hr[1];
              } else if (i < 48) {
                t += f3(br, cr, dr) + hr[2];
              } else if (i < 64) {
                t += f2(br, cr, dr) + hr[3];
              } else {
                t += f1(br, cr, dr) + hr[4];
              }
              t = t | 0;
              t = rotl(t, sr[i]);
              t = t + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t;
            }
            t = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 5; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x, y, z) {
          return x ^ y ^ z;
        }
        function f2(x, y, z) {
          return x & y | ~x & z;
        }
        function f3(x, y, z) {
          return (x | ~y) ^ z;
        }
        function f4(x, y, z) {
          return x & z | y & ~z;
        }
        function f5(x, y, z) {
          return x ^ (y | ~z);
        }
        function rotl(x, n) {
          return x << n | x >>> 32 - n;
        }
        C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })(Math);
      return CryptoJS.RIPEMD160;
    });
  }
});

// node_modules/crypto-js/hmac.js
var require_hmac = __commonJS({
  "node_modules/crypto-js/hmac.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        var HMAC = C_algo.HMAC = Base.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i = 0; i < hasherBlockSize; i++) {
              oKeyWords[i] ^= 1549556828;
              iKeyWords[i] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }
        });
      })();
    });
  }
});

// node_modules/crypto-js/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/crypto-js/pbkdf2.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha1(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA1 = C_algo.SHA1;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA1
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: SHA1,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac.update(salt).finalize(blockIndex);
              hmac.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i = 1; i < iterations; i++) {
                intermediate = hmac.finalize(intermediate);
                hmac.reset();
                var intermediateWords = intermediate.words;
                for (var j = 0; j < blockWordsLength; j++) {
                  blockWords[j] ^= intermediateWords[j];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.PBKDF2;
    });
  }
});

// node_modules/crypto-js/evpkdf.js
var require_evpkdf = __commonJS({
  "node_modules/crypto-js/evpkdf.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha1(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              var block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i = 1; i < iterations; i++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.EvpKDF;
    });
  }
});

// node_modules/crypto-js/cipher-core.js
var require_cipher_core = __commonJS({
  "node_modules/crypto-js/cipher-core.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_evpkdf());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./evpkdf"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.lib.Cipher || function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Base.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        var StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var iv = this._iv;
            if (iv) {
              var block = iv;
              this._iv = undefined2;
            } else {
              var block = this._prevBlock;
            }
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= block[i];
            }
          }
          return CBC2;
        }();
        var C_pad = C.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        var BlockCipher = C_lib.BlockCipher = Cipher.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              var modeCreator = mode.createEncryptor;
            } else {
              var modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function() {
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              var finalProcessedBlocks = this._process(true);
            } else {
              var finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              var wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              var wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(openSSLStr) {
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              var salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(ciphertext, format) {
            if (typeof ciphertext == "string") {
              return format.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(password, keySize, ivSize, salt) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  }
});

// node_modules/crypto-js/mode-cfb.js
var require_mode_cfb = __commonJS({
  "node_modules/crypto-js/mode-cfb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CFB = function() {
        var CFB = CryptoJS.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
          var iv = this._iv;
          if (iv) {
            var keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            var keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i = 0; i < blockSize; i++) {
            words[offset + i] ^= keystream[i];
          }
        }
        return CFB;
      }();
      return CryptoJS.mode.CFB;
    });
  }
});

// node_modules/crypto-js/mode-ctr.js
var require_mode_ctr = __commonJS({
  "node_modules/crypto-js/mode-ctr.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CTR = function() {
        var CTR = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS.mode.CTR;
    });
  }
});

// node_modules/crypto-js/mode-ctr-gladman.js
var require_mode_ctr_gladman = __commonJS({
  "node_modules/crypto-js/mode-ctr-gladman.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b2 === 255) {
                b2 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b2;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS.mode.CTRGladman;
    });
  }
});

// node_modules/crypto-js/mode-ofb.js
var require_mode_ofb = __commonJS({
  "node_modules/crypto-js/mode-ofb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.OFB = function() {
        var OFB = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS.mode.OFB;
    });
  }
});

// node_modules/crypto-js/mode-ecb.js
var require_mode_ecb = __commonJS({
  "node_modules/crypto-js/mode-ecb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.ECB = function() {
        var ECB = CryptoJS.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.encryptBlock(words, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.decryptBlock(words, offset);
          }
        });
        return ECB;
      }();
      return CryptoJS.mode.ECB;
    });
  }
});

// node_modules/crypto-js/pad-ansix923.js
var require_pad_ansix923 = __commonJS({
  "node_modules/crypto-js/pad-ansix923.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.AnsiX923 = {
        pad: function(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Ansix923;
    });
  }
});

// node_modules/crypto-js/pad-iso10126.js
var require_pad_iso10126 = __commonJS({
  "node_modules/crypto-js/pad-iso10126.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.Iso10126 = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Iso10126;
    });
  }
});

// node_modules/crypto-js/pad-iso97971.js
var require_pad_iso97971 = __commonJS({
  "node_modules/crypto-js/pad-iso97971.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.Iso97971 = {
        pad: function(data, blockSize) {
          data.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
          CryptoJS.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function(data) {
          CryptoJS.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      return CryptoJS.pad.Iso97971;
    });
  }
});

// node_modules/crypto-js/pad-zeropadding.js
var require_pad_zeropadding = __commonJS({
  "node_modules/crypto-js/pad-zeropadding.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.ZeroPadding = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data) {
          var dataWords = data.words;
          var i = data.sigBytes - 1;
          while (!(dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255)) {
            i--;
          }
          data.sigBytes = i + 1;
        }
      };
      return CryptoJS.pad.ZeroPadding;
    });
  }
});

// node_modules/crypto-js/pad-nopadding.js
var require_pad_nopadding = __commonJS({
  "node_modules/crypto-js/pad-nopadding.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS.pad.NoPadding;
    });
  }
});

// node_modules/crypto-js/format-hex.js
var require_format_hex = __commonJS({
  "node_modules/crypto-js/format-hex.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C.enc;
        var Hex = C_enc.Hex;
        var C_format = C.format;
        var HexFormatter = C_format.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS.format.Hex;
    });
  }
});

// node_modules/crypto-js/aes.js
var require_aes = __commonJS({
  "node_modules/crypto-js/aes.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d = [];
          for (var i = 0; i < 256; i++) {
            if (i < 128) {
              d[i] = i << 1;
            } else {
              d[i] = i << 1 ^ 283;
            }
          }
          var x = 0;
          var xi = 0;
          for (var i = 0; i < 256; i++) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];
            var t = d[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x] = t << 24 | t >>> 8;
            SUB_MIX_1[x] = t << 16 | t >>> 16;
            SUB_MIX_2[x] = t << 8 | t >>> 24;
            SUB_MIX_3[x] = t;
            var t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
            INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
            INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
            INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
            INV_SUB_MIX_3[sx] = t;
            if (!x) {
              x = xi = 1;
            } else {
              x = x2 ^ d[d[d[x8 ^ x2]]];
              xi ^= d[d[xi]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                var t = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t = t << 8 | t >>> 24;
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                  t ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t = keySchedule[ksRow];
              } else {
                var t = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
              }
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M, offset) {
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
          },
          _doCryptBlock: function(M, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M[offset] ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
            M[offset] = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
        C.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS.AES;
    });
  }
});

// node_modules/crypto-js/tripledes.js
var require_tripledes = __commonJS({
  "node_modules/crypto-js/tripledes.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i = 0; i < 56; i++) {
              var keyBitPos = PC1[i] - 1;
              keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i = 0; i < 24; i++) {
                subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i = 1; i < 7; i++) {
                subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i = 0; i < 16; i++) {
              invSubKeys[i] = subKeys[15 - i];
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._subKeys);
          },
          decryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._invSubKeys);
          },
          _doCryptBlock: function(M, offset, subKeys) {
            this._lBlock = M[offset];
            this._rBlock = M[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f = 0;
              for (var i = 0; i < 8; i++) {
                f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f;
            }
            var t = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M[offset] = this._lBlock;
            M[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset, mask) {
          var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t;
          this._lBlock ^= t << offset;
        }
        function exchangeRL(offset, mask) {
          var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t;
          this._rBlock ^= t << offset;
        }
        C.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
          },
          encryptBlock: function(M, offset) {
            this._des1.encryptBlock(M, offset);
            this._des2.decryptBlock(M, offset);
            this._des3.encryptBlock(M, offset);
          },
          decryptBlock: function(M, offset) {
            this._des3.decryptBlock(M, offset);
            this._des2.encryptBlock(M, offset);
            this._des1.decryptBlock(M, offset);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS.TripleDES;
    });
  }
});

// node_modules/crypto-js/rc4.js
var require_rc4 = __commonJS({
  "node_modules/crypto-js/rc4.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S = this._S = [];
            for (var i = 0; i < 256; i++) {
              S[i] = i;
            }
            for (var i = 0, j = 0; i < 256; i++) {
              var keyByteIndex = i % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S[i] + keyByte) % 256;
              var t = S[i];
              S[i] = S[j];
              S[j] = t;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M, offset) {
            M[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S = this._S;
          var i = this._i;
          var j = this._j;
          var keystreamWord = 0;
          for (var n = 0; n < 4; n++) {
            i = (i + 1) % 256;
            j = (j + S[i]) % 256;
            var t = S[i];
            S[i] = S[j];
            S[j] = t;
            keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;
          }
          this._i = i;
          this._j = j;
          return keystreamWord;
        }
        C.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i = this.cfg.drop; i > 0; i--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS.RC4;
    });
  }
});

// node_modules/crypto-js/rabbit.js
var require_rabbit = __commonJS({
  "node_modules/crypto-js/rabbit.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            for (var i = 0; i < 4; i++) {
              K[i] = (K[i] << 8 | K[i] >>> 24) & 16711935 | (K[i] << 24 | K[i] >>> 8) & 4278255360;
            }
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C2[i] ^= X[i + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i2;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i2;
              C2[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C2[i];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C2[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS.Rabbit;
    });
  }
});

// node_modules/crypto-js/rabbit-legacy.js
var require_rabbit_legacy = __commonJS({
  "node_modules/crypto-js/rabbit-legacy.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C2[i] ^= X[i + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i2;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i2;
              C2[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C2[i];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C2[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS.RabbitLegacy;
    });
  }
});

// node_modules/crypto-js/index.js
var require_crypto_js = __commonJS({
  "node_modules/crypto-js/index.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_lib_typedarrays(), require_enc_utf16(), require_enc_base64(), require_md5(), require_sha1(), require_sha256(), require_sha224(), require_sha512(), require_sha384(), require_sha3(), require_ripemd160(), require_hmac(), require_pbkdf2(), require_evpkdf(), require_cipher_core(), require_mode_cfb(), require_mode_ctr(), require_mode_ctr_gladman(), require_mode_ofb(), require_mode_ecb(), require_pad_ansix923(), require_pad_iso10126(), require_pad_iso97971(), require_pad_zeropadding(), require_pad_nopadding(), require_format_hex(), require_aes(), require_tripledes(), require_rc4(), require_rabbit(), require_rabbit_legacy());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy"], factory);
      } else {
        root.CryptoJS = factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      return CryptoJS;
    });
  }
});

// node_modules/web3/lib/utils/sha3.js
var require_sha32 = __commonJS({
  "node_modules/web3/lib/utils/sha3.js"(exports, module) {
    var CryptoJS = require_crypto_js();
    var sha3 = require_sha3();
    module.exports = function(value, options) {
      if (options && options.encoding === "hex") {
        if (value.length > 2 && value.substr(0, 2) === "0x") {
          value = value.substr(2);
        }
        value = CryptoJS.enc.Hex.parse(value);
      }
      return sha3(value, {
        outputLength: 256
      }).toString();
    };
  }
});

// node_modules/utf8/utf8.js
var require_utf8 = __commonJS({
  "node_modules/utf8/utf8.js"(exports, module) {
    (function(root) {
      var freeExports = typeof exports == "object" && exports;
      var freeModule = typeof module == "object" && module && module.exports == freeExports && module;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
      }
      var stringFromCharCode = String.fromCharCode;
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        var value;
        var extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        var length = array.length;
        var index = -1;
        var value;
        var output = "";
        while (++index < length) {
          value = array[index];
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
        }
        return output;
      }
      function checkScalarValue(codePoint) {
        if (codePoint >= 55296 && codePoint <= 57343) {
          throw Error(
            "Lone surrogate U+" + codePoint.toString(16).toUpperCase() + " is not a scalar value"
          );
        }
      }
      function createByte(codePoint, shift) {
        return stringFromCharCode(codePoint >> shift & 63 | 128);
      }
      function encodeCodePoint(codePoint) {
        if ((codePoint & 4294967168) == 0) {
          return stringFromCharCode(codePoint);
        }
        var symbol = "";
        if ((codePoint & 4294965248) == 0) {
          symbol = stringFromCharCode(codePoint >> 6 & 31 | 192);
        } else if ((codePoint & 4294901760) == 0) {
          checkScalarValue(codePoint);
          symbol = stringFromCharCode(codePoint >> 12 & 15 | 224);
          symbol += createByte(codePoint, 6);
        } else if ((codePoint & 4292870144) == 0) {
          symbol = stringFromCharCode(codePoint >> 18 & 7 | 240);
          symbol += createByte(codePoint, 12);
          symbol += createByte(codePoint, 6);
        }
        symbol += stringFromCharCode(codePoint & 63 | 128);
        return symbol;
      }
      function utf8encode(string) {
        var codePoints = ucs2decode(string);
        var length = codePoints.length;
        var index = -1;
        var codePoint;
        var byteString = "";
        while (++index < length) {
          codePoint = codePoints[index];
          byteString += encodeCodePoint(codePoint);
        }
        return byteString;
      }
      function readContinuationByte() {
        if (byteIndex >= byteCount) {
          throw Error("Invalid byte index");
        }
        var continuationByte = byteArray[byteIndex] & 255;
        byteIndex++;
        if ((continuationByte & 192) == 128) {
          return continuationByte & 63;
        }
        throw Error("Invalid continuation byte");
      }
      function decodeSymbol() {
        var byte1;
        var byte2;
        var byte3;
        var byte4;
        var codePoint;
        if (byteIndex > byteCount) {
          throw Error("Invalid byte index");
        }
        if (byteIndex == byteCount) {
          return false;
        }
        byte1 = byteArray[byteIndex] & 255;
        byteIndex++;
        if ((byte1 & 128) == 0) {
          return byte1;
        }
        if ((byte1 & 224) == 192) {
          byte2 = readContinuationByte();
          codePoint = (byte1 & 31) << 6 | byte2;
          if (codePoint >= 128) {
            return codePoint;
          } else {
            throw Error("Invalid continuation byte");
          }
        }
        if ((byte1 & 240) == 224) {
          byte2 = readContinuationByte();
          byte3 = readContinuationByte();
          codePoint = (byte1 & 15) << 12 | byte2 << 6 | byte3;
          if (codePoint >= 2048) {
            checkScalarValue(codePoint);
            return codePoint;
          } else {
            throw Error("Invalid continuation byte");
          }
        }
        if ((byte1 & 248) == 240) {
          byte2 = readContinuationByte();
          byte3 = readContinuationByte();
          byte4 = readContinuationByte();
          codePoint = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
          if (codePoint >= 65536 && codePoint <= 1114111) {
            return codePoint;
          }
        }
        throw Error("Invalid UTF-8 detected");
      }
      var byteArray;
      var byteCount;
      var byteIndex;
      function utf8decode(byteString) {
        byteArray = ucs2decode(byteString);
        byteCount = byteArray.length;
        byteIndex = 0;
        var codePoints = [];
        var tmp;
        while ((tmp = decodeSymbol()) !== false) {
          codePoints.push(tmp);
        }
        return ucs2encode(codePoints);
      }
      var utf8 = {
        "version": "2.1.2",
        "encode": utf8encode,
        "decode": utf8decode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define(function() {
          return utf8;
        });
      } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          freeModule.exports = utf8;
        } else {
          var object = {};
          var hasOwnProperty = object.hasOwnProperty;
          for (var key in utf8) {
            hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
          }
        }
      } else {
        root.utf8 = utf8;
      }
    })(exports);
  }
});

// node_modules/web3/lib/utils/utils.js
var require_utils = __commonJS({
  "node_modules/web3/lib/utils/utils.js"(exports, module) {
    var BigNumber = require_bignumber();
    var sha3 = require_sha32();
    var utf8 = require_utf8();
    var unitMap = {
      "noether": "0",
      "wei": "1",
      "kwei": "1000",
      "Kwei": "1000",
      "babbage": "1000",
      "femtoether": "1000",
      "mwei": "1000000",
      "Mwei": "1000000",
      "lovelace": "1000000",
      "picoether": "1000000",
      "gwei": "1000000000",
      "Gwei": "1000000000",
      "shannon": "1000000000",
      "nanoether": "1000000000",
      "nano": "1000000000",
      "szabo": "1000000000000",
      "microether": "1000000000000",
      "micro": "1000000000000",
      "finney": "1000000000000000",
      "milliether": "1000000000000000",
      "milli": "1000000000000000",
      "ether": "1000000000000000000",
      "kether": "1000000000000000000000",
      "grand": "1000000000000000000000",
      "mether": "1000000000000000000000000",
      "gether": "1000000000000000000000000000",
      "tether": "1000000000000000000000000000000"
    };
    var padLeft = function(string, chars, sign) {
      return new Array(chars - string.length + 1).join(sign ? sign : "0") + string;
    };
    var padRight = function(string, chars, sign) {
      return string + new Array(chars - string.length + 1).join(sign ? sign : "0");
    };
    var toUtf8 = function(hex) {
      var str = "";
      var i = 0, l = hex.length;
      if (hex.substring(0, 2) === "0x") {
        i = 2;
      }
      for (; i < l; i += 2) {
        var code = parseInt(hex.substr(i, 2), 16);
        if (code === 0)
          break;
        str += String.fromCharCode(code);
      }
      return utf8.decode(str);
    };
    var toAscii = function(hex) {
      var str = "";
      var i = 0, l = hex.length;
      if (hex.substring(0, 2) === "0x") {
        i = 2;
      }
      for (; i < l; i += 2) {
        var code = parseInt(hex.substr(i, 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    };
    var fromUtf8 = function(str, allowZero) {
      str = utf8.encode(str);
      var hex = "";
      for (var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        if (code === 0) {
          if (allowZero) {
            hex += "00";
          } else {
            break;
          }
        } else {
          var n = code.toString(16);
          hex += n.length < 2 ? "0" + n : n;
        }
      }
      return "0x" + hex;
    };
    var fromAscii = function(str, num) {
      var hex = "";
      for (var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        var n = code.toString(16);
        hex += n.length < 2 ? "0" + n : n;
      }
      return "0x" + hex.padEnd(num, "0");
    };
    var transformToFullName = function(json) {
      if (json.name.indexOf("(") !== -1) {
        return json.name;
      }
      var typeName = json.inputs.map(function(i) {
        return i.type;
      }).join();
      return json.name + "(" + typeName + ")";
    };
    var extractDisplayName = function(name) {
      var stBracket = name.indexOf("(");
      var endBracket = name.indexOf(")");
      return stBracket !== -1 && endBracket !== -1 ? name.substr(0, stBracket) : name;
    };
    var extractTypeName = function(name) {
      var stBracket = name.indexOf("(");
      var endBracket = name.indexOf(")");
      return stBracket !== -1 && endBracket !== -1 ? name.substr(stBracket + 1, endBracket - stBracket - 1).replace(" ", "") : "";
    };
    var toDecimal = function(value) {
      return toBigNumber(value).toNumber();
    };
    var fromDecimal = function(value) {
      var number = toBigNumber(value);
      var result = number.toString(16);
      return number.lessThan(0) ? "-0x" + result.substr(1) : "0x" + result;
    };
    var toHex = function(val) {
      if (isBoolean(val))
        return fromDecimal(+val);
      if (isBigNumber(val))
        return fromDecimal(val);
      if (typeof val === "object")
        return fromUtf8(JSON.stringify(val));
      if (isString(val)) {
        if (val.indexOf("-0x") === 0)
          return fromDecimal(val);
        else if (val.indexOf("0x") === 0)
          return val;
        else if (!isFinite(val))
          return fromUtf8(val, 1);
      }
      return fromDecimal(val);
    };
    var getValueOfUnit = function(unit) {
      unit = unit ? unit.toLowerCase() : "ether";
      var unitValue = unitMap[unit];
      if (unitValue === void 0) {
        throw new Error("This unit doesn't exists, please use the one of the following units" + JSON.stringify(unitMap, null, 2));
      }
      return new BigNumber(unitValue, 10);
    };
    var fromWei = function(number, unit) {
      var returnValue = toBigNumber(number).dividedBy(getValueOfUnit(unit));
      return isBigNumber(number) ? returnValue : returnValue.toString(10);
    };
    var toWei = function(number, unit) {
      var returnValue = toBigNumber(number).times(getValueOfUnit(unit));
      return isBigNumber(number) ? returnValue : returnValue.toString(10);
    };
    var toBigNumber = function(number) {
      number = number || 0;
      if (isBigNumber(number))
        return number;
      if (isString(number) && (number.indexOf("0x") === 0 || number.indexOf("-0x") === 0)) {
        return new BigNumber(number.replace("0x", ""), 16);
      }
      return new BigNumber(number.toString(10), 10);
    };
    var toTwosComplement = function(number) {
      var bigNumber = toBigNumber(number).round();
      if (bigNumber.lessThan(0)) {
        return new BigNumber("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16).plus(bigNumber).plus(1);
      }
      return bigNumber;
    };
    var isStrictAddress = function(address) {
      return /^0x[0-9a-f]{40}$/i.test(address);
    };
    var isAddress = function(address) {
      if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
        return false;
      } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
        return true;
      } else {
        return isChecksumAddress(address);
      }
    };
    var isChecksumAddress = function(address) {
      address = address.replace("0x", "");
      var addressHash = sha3(address.toLowerCase());
      for (var i = 0; i < 40; i++) {
        if (parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i] || parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i]) {
          return false;
        }
      }
      return true;
    };
    var toChecksumAddress = function(address) {
      if (typeof address === "undefined")
        return "";
      address = address.toLowerCase().replace("0x", "");
      var addressHash = sha3(address);
      var checksumAddress = "0x";
      for (var i = 0; i < address.length; i++) {
        if (parseInt(addressHash[i], 16) > 7) {
          checksumAddress += address[i].toUpperCase();
        } else {
          checksumAddress += address[i];
        }
      }
      return checksumAddress;
    };
    var toAddress = function(address) {
      if (isStrictAddress(address)) {
        return address;
      }
      if (/^[0-9a-f]{40}$/.test(address)) {
        return "0x" + address;
      }
      return "0x" + padLeft(toHex(address).substr(2), 40);
    };
    var isBigNumber = function(object) {
      return object instanceof BigNumber || object && object.constructor && object.constructor.name === "BigNumber";
    };
    var isString = function(object) {
      return typeof object === "string" || object && object.constructor && object.constructor.name === "String";
    };
    var isFunction = function(object) {
      return typeof object === "function";
    };
    var isObject = function(object) {
      return object !== null && !Array.isArray(object) && typeof object === "object";
    };
    var isBoolean = function(object) {
      return typeof object === "boolean";
    };
    var isArray = function(object) {
      return Array.isArray(object);
    };
    var isJson = function(str) {
      try {
        return !!JSON.parse(str);
      } catch (e) {
        return false;
      }
    };
    var isBloom = function(bloom) {
      if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {
        return false;
      } else if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {
        return true;
      }
      return false;
    };
    var isTopic = function(topic) {
      if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {
        return false;
      } else if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {
        return true;
      }
      return false;
    };
    module.exports = {
      padLeft,
      padRight,
      toHex,
      toDecimal,
      fromDecimal,
      toUtf8,
      toAscii,
      fromUtf8,
      fromAscii,
      transformToFullName,
      extractDisplayName,
      extractTypeName,
      toWei,
      fromWei,
      toBigNumber,
      toTwosComplement,
      toAddress,
      isBigNumber,
      isStrictAddress,
      isAddress,
      isChecksumAddress,
      toChecksumAddress,
      isFunction,
      isString,
      isObject,
      isBoolean,
      isArray,
      isJson,
      isBloom,
      isTopic
    };
  }
});

// node_modules/web3/lib/utils/config.js
var require_config = __commonJS({
  "node_modules/web3/lib/utils/config.js"(exports, module) {
    var BigNumber = require_bignumber();
    var ETH_UNITS = [
      "wei",
      "kwei",
      "Mwei",
      "Gwei",
      "szabo",
      "finney",
      "femtoether",
      "picoether",
      "nanoether",
      "microether",
      "milliether",
      "nano",
      "micro",
      "milli",
      "ether",
      "grand",
      "Mether",
      "Gether",
      "Tether",
      "Pether",
      "Eether",
      "Zether",
      "Yether",
      "Nether",
      "Dether",
      "Vether",
      "Uether"
    ];
    module.exports = {
      ETH_PADDING: 32,
      ETH_SIGNATURE_LENGTH: 4,
      ETH_UNITS,
      ETH_BIGNUMBER_ROUNDING_MODE: { ROUNDING_MODE: BigNumber.ROUND_DOWN },
      ETH_POLLING_TIMEOUT: 1e3 / 2,
      defaultBlock: "latest",
      defaultAccount: void 0
    };
  }
});

// node_modules/web3/lib/web3/errors.js
var require_errors = __commonJS({
  "node_modules/web3/lib/web3/errors.js"(exports, module) {
    module.exports = {
      InvalidNumberOfSolidityArgs: function() {
        return new Error("Invalid number of arguments to Solidity function");
      },
      InvalidNumberOfRPCParams: function() {
        return new Error("Invalid number of input parameters to RPC method");
      },
      InvalidConnection: function(host) {
        return new Error("CONNECTION ERROR: Couldn't connect to node " + host + ".");
      },
      InvalidProvider: function() {
        return new Error("Provider not set or invalid");
      },
      InvalidResponse: function(result) {
        var message = !!result && !!result.error && !!result.error.message ? result.error.message : "Invalid JSON RPC response: " + JSON.stringify(result);
        return new Error(message);
      },
      ConnectionTimeout: function(ms) {
        return new Error("CONNECTION TIMEOUT: timeout of " + ms + " ms achived");
      }
    };
  }
});

// node_modules/web3/lib/web3/requestmanager.js
var require_requestmanager = __commonJS({
  "node_modules/web3/lib/web3/requestmanager.js"(exports, module) {
    var Jsonrpc = require_jsonrpc();
    var utils = require_utils();
    var c = require_config();
    var errors = require_errors();
    var RequestManager = function(provider) {
      this.provider = provider;
      this.polls = {};
      this.timeout = null;
    };
    RequestManager.prototype.send = function(data) {
      if (!this.provider) {
        console.error(errors.InvalidProvider());
        return null;
      }
      var payload = Jsonrpc.toPayload(data.method, data.params);
      var result = this.provider.send(payload);
      if (!Jsonrpc.isValidResponse(result)) {
        throw errors.InvalidResponse(result);
      }
      return result.result;
    };
    RequestManager.prototype.sendAsync = function(data, callback) {
      if (!this.provider) {
        return callback(errors.InvalidProvider());
      }
      var payload = Jsonrpc.toPayload(data.method, data.params);
      this.provider.sendAsync(payload, function(err, result) {
        if (err) {
          return callback(err);
        }
        if (!Jsonrpc.isValidResponse(result)) {
          return callback(errors.InvalidResponse(result));
        }
        callback(null, result.result);
      });
    };
    RequestManager.prototype.sendBatch = function(data, callback) {
      if (!this.provider) {
        return callback(errors.InvalidProvider());
      }
      var payload = Jsonrpc.toBatchPayload(data);
      this.provider.sendAsync(payload, function(err, results) {
        if (err) {
          return callback(err);
        }
        if (!utils.isArray(results)) {
          return callback(errors.InvalidResponse(results));
        }
        callback(err, results);
      });
    };
    RequestManager.prototype.setProvider = function(p) {
      this.provider = p;
    };
    RequestManager.prototype.startPolling = function(data, pollId, callback, uninstall) {
      this.polls[pollId] = { data, id: pollId, callback, uninstall };
      if (!this.timeout) {
        this.poll();
      }
    };
    RequestManager.prototype.stopPolling = function(pollId) {
      delete this.polls[pollId];
      if (Object.keys(this.polls).length === 0 && this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
      }
    };
    RequestManager.prototype.reset = function(keepIsSyncing) {
      for (var key in this.polls) {
        if (!keepIsSyncing || key.indexOf("syncPoll_") === -1) {
          this.polls[key].uninstall();
          delete this.polls[key];
        }
      }
      if (Object.keys(this.polls).length === 0 && this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
      }
    };
    RequestManager.prototype.poll = function() {
      this.timeout = setTimeout(this.poll.bind(this), c.ETH_POLLING_TIMEOUT);
      if (Object.keys(this.polls).length === 0) {
        return;
      }
      if (!this.provider) {
        console.error(errors.InvalidProvider());
        return;
      }
      var pollsData = [];
      var pollsIds = [];
      for (var key in this.polls) {
        pollsData.push(this.polls[key].data);
        pollsIds.push(key);
      }
      if (pollsData.length === 0) {
        return;
      }
      var payload = Jsonrpc.toBatchPayload(pollsData);
      var pollsIdMap = {};
      payload.forEach(function(load, index) {
        pollsIdMap[load.id] = pollsIds[index];
      });
      var self = this;
      this.provider.sendAsync(payload, function(error, results) {
        if (error) {
          return;
        }
        if (!utils.isArray(results)) {
          throw errors.InvalidResponse(results);
        }
        results.map(function(result) {
          var id = pollsIdMap[result.id];
          if (self.polls[id]) {
            result.callback = self.polls[id].callback;
            return result;
          } else
            return false;
        }).filter(function(result) {
          return !!result;
        }).filter(function(result) {
          var valid = Jsonrpc.isValidResponse(result);
          if (!valid) {
            result.callback(errors.InvalidResponse(result));
          }
          return valid;
        }).forEach(function(result) {
          result.callback(null, result.result);
        });
      });
    };
    module.exports = RequestManager;
  }
});

// node_modules/web3/lib/web3/iban.js
var require_iban = __commonJS({
  "node_modules/web3/lib/web3/iban.js"(exports, module) {
    var BigNumber = require_bignumber();
    var padLeft = function(string, bytes) {
      var result = string;
      while (result.length < bytes * 2) {
        result = "0" + result;
      }
      return result;
    };
    var iso13616Prepare = function(iban) {
      var A = "A".charCodeAt(0);
      var Z = "Z".charCodeAt(0);
      iban = iban.toUpperCase();
      iban = iban.substr(4) + iban.substr(0, 4);
      return iban.split("").map(function(n) {
        var code = n.charCodeAt(0);
        if (code >= A && code <= Z) {
          return code - A + 10;
        } else {
          return n;
        }
      }).join("");
    };
    var mod9710 = function(iban) {
      var remainder = iban, block;
      while (remainder.length > 2) {
        block = remainder.slice(0, 9);
        remainder = parseInt(block, 10) % 97 + remainder.slice(block.length);
      }
      return parseInt(remainder, 10) % 97;
    };
    var Iban = function(iban) {
      this._iban = iban;
    };
    Iban.fromAddress = function(address) {
      var asBn = new BigNumber(address, 16);
      var base36 = asBn.toString(36);
      var padded = padLeft(base36, 15);
      return Iban.fromBban(padded.toUpperCase());
    };
    Iban.fromBban = function(bban) {
      var countryCode = "XE";
      var remainder = mod9710(iso13616Prepare(countryCode + "00" + bban));
      var checkDigit = ("0" + (98 - remainder)).slice(-2);
      return new Iban(countryCode + checkDigit + bban);
    };
    Iban.createIndirect = function(options) {
      return Iban.fromBban("ETH" + options.institution + options.identifier);
    };
    Iban.isValid = function(iban) {
      var i = new Iban(iban);
      return i.isValid();
    };
    Iban.prototype.isValid = function() {
      return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(this._iban) && mod9710(iso13616Prepare(this._iban)) === 1;
    };
    Iban.prototype.isDirect = function() {
      return this._iban.length === 34 || this._iban.length === 35;
    };
    Iban.prototype.isIndirect = function() {
      return this._iban.length === 20;
    };
    Iban.prototype.checksum = function() {
      return this._iban.substr(2, 2);
    };
    Iban.prototype.institution = function() {
      return this.isIndirect() ? this._iban.substr(7, 4) : "";
    };
    Iban.prototype.client = function() {
      return this.isIndirect() ? this._iban.substr(11) : "";
    };
    Iban.prototype.address = function() {
      if (this.isDirect()) {
        var base36 = this._iban.substr(4);
        var asBn = new BigNumber(base36, 36);
        return padLeft(asBn.toString(16), 20);
      }
      return "";
    };
    Iban.prototype.toString = function() {
      return this._iban;
    };
    module.exports = Iban;
  }
});

// node_modules/web3/lib/web3/formatters.js
var require_formatters = __commonJS({
  "node_modules/web3/lib/web3/formatters.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var config = require_config();
    var Iban = require_iban();
    var outputBigNumberFormatter = function(number) {
      return utils.toBigNumber(number);
    };
    var isPredefinedBlockNumber = function(blockNumber) {
      return blockNumber === "latest" || blockNumber === "pending" || blockNumber === "earliest";
    };
    var inputDefaultBlockNumberFormatter = function(blockNumber) {
      if (blockNumber === void 0) {
        return config.defaultBlock;
      }
      return inputBlockNumberFormatter(blockNumber);
    };
    var inputBlockNumberFormatter = function(blockNumber) {
      if (blockNumber === void 0) {
        return void 0;
      } else if (isPredefinedBlockNumber(blockNumber)) {
        return blockNumber;
      }
      return utils.toHex(blockNumber);
    };
    var inputCallFormatter = function(options) {
      options.from = options.from || config.defaultAccount;
      if (options.from) {
        options.from = inputAddressFormatter(options.from);
      }
      if (options.to) {
        options.to = inputAddressFormatter(options.to);
      }
      ["gasPrice", "gas", "value", "nonce"].filter(function(key) {
        return options[key] !== void 0;
      }).forEach(function(key) {
        options[key] = utils.fromDecimal(options[key]);
      });
      return options;
    };
    var inputTransactionFormatter = function(options) {
      options.from = options.from || config.defaultAccount;
      options.from = inputAddressFormatter(options.from);
      if (options.to) {
        options.to = inputAddressFormatter(options.to);
      }
      ["gasPrice", "gas", "value", "nonce"].filter(function(key) {
        return options[key] !== void 0;
      }).forEach(function(key) {
        options[key] = utils.fromDecimal(options[key]);
      });
      return options;
    };
    var outputTransactionFormatter = function(tx) {
      if (tx.blockNumber !== null)
        tx.blockNumber = utils.toDecimal(tx.blockNumber);
      if (tx.transactionIndex !== null)
        tx.transactionIndex = utils.toDecimal(tx.transactionIndex);
      tx.nonce = utils.toDecimal(tx.nonce);
      tx.gas = utils.toDecimal(tx.gas);
      tx.gasPrice = utils.toBigNumber(tx.gasPrice);
      tx.value = utils.toBigNumber(tx.value);
      return tx;
    };
    var outputTransactionReceiptFormatter = function(receipt) {
      if (receipt.blockNumber !== null)
        receipt.blockNumber = utils.toDecimal(receipt.blockNumber);
      if (receipt.transactionIndex !== null)
        receipt.transactionIndex = utils.toDecimal(receipt.transactionIndex);
      receipt.cumulativeGasUsed = utils.toDecimal(receipt.cumulativeGasUsed);
      receipt.gasUsed = utils.toDecimal(receipt.gasUsed);
      if (utils.isArray(receipt.logs)) {
        receipt.logs = receipt.logs.map(function(log) {
          return outputLogFormatter(log);
        });
      }
      return receipt;
    };
    var outputBlockFormatter = function(block) {
      block.gasLimit = utils.toDecimal(block.gasLimit);
      block.gasUsed = utils.toDecimal(block.gasUsed);
      block.size = utils.toDecimal(block.size);
      block.timestamp = utils.toDecimal(block.timestamp);
      if (block.number !== null)
        block.number = utils.toDecimal(block.number);
      block.difficulty = utils.toBigNumber(block.difficulty);
      block.totalDifficulty = utils.toBigNumber(block.totalDifficulty);
      if (utils.isArray(block.transactions)) {
        block.transactions.forEach(function(item) {
          if (!utils.isString(item))
            return outputTransactionFormatter(item);
        });
      }
      return block;
    };
    var outputLogFormatter = function(log) {
      if (log.blockNumber)
        log.blockNumber = utils.toDecimal(log.blockNumber);
      if (log.transactionIndex)
        log.transactionIndex = utils.toDecimal(log.transactionIndex);
      if (log.logIndex)
        log.logIndex = utils.toDecimal(log.logIndex);
      return log;
    };
    var inputPostFormatter = function(post) {
      post.ttl = utils.fromDecimal(post.ttl);
      post.workToProve = utils.fromDecimal(post.workToProve);
      post.priority = utils.fromDecimal(post.priority);
      if (!utils.isArray(post.topics)) {
        post.topics = post.topics ? [post.topics] : [];
      }
      post.topics = post.topics.map(function(topic) {
        return topic.indexOf("0x") === 0 ? topic : utils.fromUtf8(topic);
      });
      return post;
    };
    var outputPostFormatter = function(post) {
      post.expiry = utils.toDecimal(post.expiry);
      post.sent = utils.toDecimal(post.sent);
      post.ttl = utils.toDecimal(post.ttl);
      post.workProved = utils.toDecimal(post.workProved);
      if (!post.topics) {
        post.topics = [];
      }
      post.topics = post.topics.map(function(topic) {
        return utils.toAscii(topic);
      });
      return post;
    };
    var inputAddressFormatter = function(address) {
      var iban = new Iban(address);
      if (iban.isValid() && iban.isDirect()) {
        return "0x" + iban.address();
      } else if (utils.isStrictAddress(address)) {
        return address;
      } else if (utils.isAddress(address)) {
        return "0x" + address;
      }
      throw new Error("invalid address");
    };
    var outputSyncingFormatter = function(result) {
      if (!result) {
        return result;
      }
      result.startingBlock = utils.toDecimal(result.startingBlock);
      result.currentBlock = utils.toDecimal(result.currentBlock);
      result.highestBlock = utils.toDecimal(result.highestBlock);
      if (result.knownStates) {
        result.knownStates = utils.toDecimal(result.knownStates);
        result.pulledStates = utils.toDecimal(result.pulledStates);
      }
      return result;
    };
    module.exports = {
      inputDefaultBlockNumberFormatter,
      inputBlockNumberFormatter,
      inputCallFormatter,
      inputTransactionFormatter,
      inputAddressFormatter,
      inputPostFormatter,
      outputBigNumberFormatter,
      outputTransactionFormatter,
      outputTransactionReceiptFormatter,
      outputBlockFormatter,
      outputLogFormatter,
      outputPostFormatter,
      outputSyncingFormatter
    };
  }
});

// node_modules/web3/lib/web3/method.js
var require_method = __commonJS({
  "node_modules/web3/lib/web3/method.js"(exports, module) {
    var utils = require_utils();
    var errors = require_errors();
    var Method = function(options) {
      this.name = options.name;
      this.call = options.call;
      this.params = options.params || 0;
      this.inputFormatter = options.inputFormatter;
      this.outputFormatter = options.outputFormatter;
      this.requestManager = null;
    };
    Method.prototype.setRequestManager = function(rm) {
      this.requestManager = rm;
    };
    Method.prototype.getCall = function(args) {
      return utils.isFunction(this.call) ? this.call(args) : this.call;
    };
    Method.prototype.extractCallback = function(args) {
      if (utils.isFunction(args[args.length - 1])) {
        return args.pop();
      }
    };
    Method.prototype.validateArgs = function(args) {
      if (args.length !== this.params) {
        throw errors.InvalidNumberOfRPCParams();
      }
    };
    Method.prototype.formatInput = function(args) {
      if (!this.inputFormatter) {
        return args;
      }
      return this.inputFormatter.map(function(formatter, index) {
        return formatter ? formatter(args[index]) : args[index];
      });
    };
    Method.prototype.formatOutput = function(result) {
      return this.outputFormatter && result ? this.outputFormatter(result) : result;
    };
    Method.prototype.toPayload = function(args) {
      var call = this.getCall(args);
      var callback = this.extractCallback(args);
      var params = this.formatInput(args);
      this.validateArgs(params);
      return {
        method: call,
        params,
        callback
      };
    };
    Method.prototype.attachToObject = function(obj) {
      var func = this.buildCall();
      func.call = this.call;
      var name = this.name.split(".");
      if (name.length > 1) {
        obj[name[0]] = obj[name[0]] || {};
        obj[name[0]][name[1]] = func;
      } else {
        obj[name[0]] = func;
      }
    };
    Method.prototype.buildCall = function() {
      var method = this;
      var send = function() {
        var payload = method.toPayload(Array.prototype.slice.call(arguments));
        if (payload.callback) {
          return method.requestManager.sendAsync(payload, function(err, result) {
            payload.callback(err, method.formatOutput(result));
          });
        }
        return method.formatOutput(method.requestManager.send(payload));
      };
      send.request = this.request.bind(this);
      return send;
    };
    Method.prototype.request = function() {
      var payload = this.toPayload(Array.prototype.slice.call(arguments));
      payload.format = this.formatOutput.bind(this);
      return payload;
    };
    module.exports = Method;
  }
});

// node_modules/web3/lib/web3/property.js
var require_property = __commonJS({
  "node_modules/web3/lib/web3/property.js"(exports, module) {
    var utils = require_utils();
    var Property = function(options) {
      this.name = options.name;
      this.getter = options.getter;
      this.setter = options.setter;
      this.outputFormatter = options.outputFormatter;
      this.inputFormatter = options.inputFormatter;
      this.requestManager = null;
    };
    Property.prototype.setRequestManager = function(rm) {
      this.requestManager = rm;
    };
    Property.prototype.formatInput = function(arg) {
      return this.inputFormatter ? this.inputFormatter(arg) : arg;
    };
    Property.prototype.formatOutput = function(result) {
      return this.outputFormatter && result !== null && result !== void 0 ? this.outputFormatter(result) : result;
    };
    Property.prototype.extractCallback = function(args) {
      if (utils.isFunction(args[args.length - 1])) {
        return args.pop();
      }
    };
    Property.prototype.attachToObject = function(obj) {
      var proto = {
        get: this.buildGet(),
        enumerable: true
      };
      var names = this.name.split(".");
      var name = names[0];
      if (names.length > 1) {
        obj[names[0]] = obj[names[0]] || {};
        obj = obj[names[0]];
        name = names[1];
      }
      Object.defineProperty(obj, name, proto);
      obj[asyncGetterName(name)] = this.buildAsyncGet();
    };
    var asyncGetterName = function(name) {
      return "get" + name.charAt(0).toUpperCase() + name.slice(1);
    };
    Property.prototype.buildGet = function() {
      var property = this;
      return function get() {
        return property.formatOutput(property.requestManager.send({
          method: property.getter
        }));
      };
    };
    Property.prototype.buildAsyncGet = function() {
      var property = this;
      var get = function(callback) {
        property.requestManager.sendAsync({
          method: property.getter
        }, function(err, result) {
          callback(err, property.formatOutput(result));
        });
      };
      get.request = this.request.bind(this);
      return get;
    };
    Property.prototype.request = function() {
      var payload = {
        method: this.getter,
        params: [],
        callback: this.extractCallback(Array.prototype.slice.call(arguments))
      };
      payload.format = this.formatOutput.bind(this);
      return payload;
    };
    module.exports = Property;
  }
});

// node_modules/web3/lib/solidity/param.js
var require_param = __commonJS({
  "node_modules/web3/lib/solidity/param.js"(exports, module) {
    var utils = require_utils();
    var SolidityParam = function(value, offset) {
      this.value = value || "";
      this.offset = offset;
    };
    SolidityParam.prototype.dynamicPartLength = function() {
      return this.dynamicPart().length / 2;
    };
    SolidityParam.prototype.withOffset = function(offset) {
      return new SolidityParam(this.value, offset);
    };
    SolidityParam.prototype.combine = function(param) {
      return new SolidityParam(this.value + param.value);
    };
    SolidityParam.prototype.isDynamic = function() {
      return this.offset !== void 0;
    };
    SolidityParam.prototype.offsetAsBytes = function() {
      return !this.isDynamic() ? "" : utils.padLeft(utils.toTwosComplement(this.offset).toString(16), 64);
    };
    SolidityParam.prototype.staticPart = function() {
      if (!this.isDynamic()) {
        return this.value;
      }
      return this.offsetAsBytes();
    };
    SolidityParam.prototype.dynamicPart = function() {
      return this.isDynamic() ? this.value : "";
    };
    SolidityParam.prototype.encode = function() {
      return this.staticPart() + this.dynamicPart();
    };
    SolidityParam.encodeList = function(params) {
      var totalOffset = params.length * 32;
      var offsetParams = params.map(function(param) {
        if (!param.isDynamic()) {
          return param;
        }
        var offset = totalOffset;
        totalOffset += param.dynamicPartLength();
        return param.withOffset(offset);
      });
      return offsetParams.reduce(function(result, param) {
        return result + param.dynamicPart();
      }, offsetParams.reduce(function(result, param) {
        return result + param.staticPart();
      }, ""));
    };
    module.exports = SolidityParam;
  }
});

// node_modules/web3/lib/solidity/formatters.js
var require_formatters2 = __commonJS({
  "node_modules/web3/lib/solidity/formatters.js"(exports, module) {
    var BigNumber = require_bignumber();
    var utils = require_utils();
    var c = require_config();
    var SolidityParam = require_param();
    var formatInputInt = function(value) {
      BigNumber.config(c.ETH_BIGNUMBER_ROUNDING_MODE);
      var result = utils.padLeft(utils.toTwosComplement(value).toString(16), 64);
      return new SolidityParam(result);
    };
    var formatInputBytes = function(value) {
      var result = utils.toHex(value).substr(2);
      var l = Math.floor((result.length + 63) / 64);
      result = utils.padRight(result, l * 64);
      return new SolidityParam(result);
    };
    var formatInputDynamicBytes = function(value) {
      var result = utils.toHex(value).substr(2);
      var length = result.length / 2;
      var l = Math.floor((result.length + 63) / 64);
      result = utils.padRight(result, l * 64);
      return new SolidityParam(formatInputInt(length).value + result);
    };
    var formatInputString = function(value) {
      var result = utils.fromUtf8(value).substr(2);
      var length = result.length / 2;
      var l = Math.floor((result.length + 63) / 64);
      result = utils.padRight(result, l * 64);
      return new SolidityParam(formatInputInt(length).value + result);
    };
    var formatInputBool = function(value) {
      var result = "000000000000000000000000000000000000000000000000000000000000000" + (value ? "1" : "0");
      return new SolidityParam(result);
    };
    var formatInputReal = function(value) {
      return formatInputInt(new BigNumber(value).times(new BigNumber(2).pow(128)));
    };
    var signedIsNegative = function(value) {
      return new BigNumber(value.substr(0, 1), 16).toString(2).substr(0, 1) === "1";
    };
    var formatOutputInt = function(param) {
      var value = param.staticPart() || "0";
      if (signedIsNegative(value)) {
        return new BigNumber(value, 16).minus(new BigNumber("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16)).minus(1);
      }
      return new BigNumber(value, 16);
    };
    var formatOutputUInt = function(param) {
      var value = param.staticPart() || "0";
      return new BigNumber(value, 16);
    };
    var formatOutputReal = function(param) {
      return formatOutputInt(param).dividedBy(new BigNumber(2).pow(128));
    };
    var formatOutputUReal = function(param) {
      return formatOutputUInt(param).dividedBy(new BigNumber(2).pow(128));
    };
    var formatOutputBool = function(param) {
      return param.staticPart() === "0000000000000000000000000000000000000000000000000000000000000001" ? true : false;
    };
    var formatOutputBytes = function(param, name) {
      var matches = name.match(/^bytes([0-9]*)/);
      var size = parseInt(matches[1]);
      return "0x" + param.staticPart().slice(0, 2 * size);
    };
    var formatOutputDynamicBytes = function(param) {
      var length = new BigNumber(param.dynamicPart().slice(0, 64), 16).toNumber() * 2;
      return "0x" + param.dynamicPart().substr(64, length);
    };
    var formatOutputString = function(param) {
      var length = new BigNumber(param.dynamicPart().slice(0, 64), 16).toNumber() * 2;
      return utils.toUtf8(param.dynamicPart().substr(64, length));
    };
    var formatOutputAddress = function(param) {
      var value = param.staticPart();
      return "0x" + value.slice(value.length - 40, value.length);
    };
    module.exports = {
      formatInputInt,
      formatInputBytes,
      formatInputDynamicBytes,
      formatInputString,
      formatInputBool,
      formatInputReal,
      formatOutputInt,
      formatOutputUInt,
      formatOutputReal,
      formatOutputUReal,
      formatOutputBool,
      formatOutputBytes,
      formatOutputDynamicBytes,
      formatOutputString,
      formatOutputAddress
    };
  }
});

// node_modules/web3/lib/solidity/type.js
var require_type = __commonJS({
  "node_modules/web3/lib/solidity/type.js"(exports, module) {
    var f = require_formatters2();
    var SolidityParam = require_param();
    var SolidityType = function(config) {
      this._inputFormatter = config.inputFormatter;
      this._outputFormatter = config.outputFormatter;
    };
    SolidityType.prototype.isType = function(name) {
      throw "this method should be overrwritten for type " + name;
    };
    SolidityType.prototype.staticPartLength = function(name) {
      return (this.nestedTypes(name) || ["[1]"]).map(function(type) {
        return parseInt(type.slice(1, -1), 10) || 1;
      }).reduce(function(previous, current) {
        return previous * current;
      }, 32);
    };
    SolidityType.prototype.isDynamicArray = function(name) {
      var nestedTypes = this.nestedTypes(name);
      return !!nestedTypes && !nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);
    };
    SolidityType.prototype.isStaticArray = function(name) {
      var nestedTypes = this.nestedTypes(name);
      return !!nestedTypes && !!nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);
    };
    SolidityType.prototype.staticArrayLength = function(name) {
      var nestedTypes = this.nestedTypes(name);
      if (nestedTypes) {
        return parseInt(nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g) || 1);
      }
      return 1;
    };
    SolidityType.prototype.nestedName = function(name) {
      var nestedTypes = this.nestedTypes(name);
      if (!nestedTypes) {
        return name;
      }
      return name.substr(0, name.length - nestedTypes[nestedTypes.length - 1].length);
    };
    SolidityType.prototype.isDynamicType = function() {
      return false;
    };
    SolidityType.prototype.nestedTypes = function(name) {
      return name.match(/(\[[0-9]*\])/g);
    };
    SolidityType.prototype.encode = function(value, name) {
      var self = this;
      if (this.isDynamicArray(name)) {
        return function() {
          var length = value.length;
          var nestedName = self.nestedName(name);
          var result = [];
          result.push(f.formatInputInt(length).encode());
          value.forEach(function(v) {
            result.push(self.encode(v, nestedName));
          });
          return result;
        }();
      } else if (this.isStaticArray(name)) {
        return function() {
          var length = self.staticArrayLength(name);
          var nestedName = self.nestedName(name);
          var result = [];
          for (var i = 0; i < length; i++) {
            result.push(self.encode(value[i], nestedName));
          }
          return result;
        }();
      }
      return this._inputFormatter(value, name).encode();
    };
    SolidityType.prototype.decode = function(bytes, offset, name) {
      var self = this;
      if (this.isDynamicArray(name)) {
        return function() {
          var arrayOffset = parseInt("0x" + bytes.substr(offset * 2, 64));
          var length2 = parseInt("0x" + bytes.substr(arrayOffset * 2, 64));
          var arrayStart = arrayOffset + 32;
          var nestedName = self.nestedName(name);
          var nestedStaticPartLength = self.staticPartLength(nestedName);
          var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;
          var result = [];
          for (var i = 0; i < length2 * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {
            result.push(self.decode(bytes, arrayStart + i, nestedName));
          }
          return result;
        }();
      } else if (this.isStaticArray(name)) {
        return function() {
          var length2 = self.staticArrayLength(name);
          var arrayStart = offset;
          var nestedName = self.nestedName(name);
          var nestedStaticPartLength = self.staticPartLength(nestedName);
          var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;
          var result = [];
          for (var i = 0; i < length2 * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {
            result.push(self.decode(bytes, arrayStart + i, nestedName));
          }
          return result;
        }();
      } else if (this.isDynamicType(name)) {
        return function() {
          var dynamicOffset = parseInt("0x" + bytes.substr(offset * 2, 64));
          var length2 = parseInt("0x" + bytes.substr(dynamicOffset * 2, 64));
          var roundedLength = Math.floor((length2 + 31) / 32);
          var param2 = new SolidityParam(bytes.substr(dynamicOffset * 2, (1 + roundedLength) * 64), 0);
          return self._outputFormatter(param2, name);
        }();
      }
      var length = this.staticPartLength(name);
      var param = new SolidityParam(bytes.substr(offset * 2, length * 2));
      return this._outputFormatter(param, name);
    };
    module.exports = SolidityType;
  }
});

// node_modules/web3/lib/solidity/address.js
var require_address = __commonJS({
  "node_modules/web3/lib/solidity/address.js"(exports, module) {
    var f = require_formatters2();
    var SolidityType = require_type();
    var SolidityTypeAddress = function() {
      this._inputFormatter = f.formatInputInt;
      this._outputFormatter = f.formatOutputAddress;
    };
    SolidityTypeAddress.prototype = new SolidityType({});
    SolidityTypeAddress.prototype.constructor = SolidityTypeAddress;
    SolidityTypeAddress.prototype.isType = function(name) {
      return !!name.match(/address(\[([0-9]*)\])?/);
    };
    module.exports = SolidityTypeAddress;
  }
});

// node_modules/web3/lib/solidity/bool.js
var require_bool = __commonJS({
  "node_modules/web3/lib/solidity/bool.js"(exports, module) {
    var f = require_formatters2();
    var SolidityType = require_type();
    var SolidityTypeBool = function() {
      this._inputFormatter = f.formatInputBool;
      this._outputFormatter = f.formatOutputBool;
    };
    SolidityTypeBool.prototype = new SolidityType({});
    SolidityTypeBool.prototype.constructor = SolidityTypeBool;
    SolidityTypeBool.prototype.isType = function(name) {
      return !!name.match(/^bool(\[([0-9]*)\])*$/);
    };
    module.exports = SolidityTypeBool;
  }
});

// node_modules/web3/lib/solidity/int.js
var require_int = __commonJS({
  "node_modules/web3/lib/solidity/int.js"(exports, module) {
    var f = require_formatters2();
    var SolidityType = require_type();
    var SolidityTypeInt = function() {
      this._inputFormatter = f.formatInputInt;
      this._outputFormatter = f.formatOutputInt;
    };
    SolidityTypeInt.prototype = new SolidityType({});
    SolidityTypeInt.prototype.constructor = SolidityTypeInt;
    SolidityTypeInt.prototype.isType = function(name) {
      return !!name.match(/^int([0-9]*)?(\[([0-9]*)\])*$/);
    };
    module.exports = SolidityTypeInt;
  }
});

// node_modules/web3/lib/solidity/uint.js
var require_uint = __commonJS({
  "node_modules/web3/lib/solidity/uint.js"(exports, module) {
    var f = require_formatters2();
    var SolidityType = require_type();
    var SolidityTypeUInt = function() {
      this._inputFormatter = f.formatInputInt;
      this._outputFormatter = f.formatOutputUInt;
    };
    SolidityTypeUInt.prototype = new SolidityType({});
    SolidityTypeUInt.prototype.constructor = SolidityTypeUInt;
    SolidityTypeUInt.prototype.isType = function(name) {
      return !!name.match(/^uint([0-9]*)?(\[([0-9]*)\])*$/);
    };
    module.exports = SolidityTypeUInt;
  }
});

// node_modules/web3/lib/solidity/dynamicbytes.js
var require_dynamicbytes = __commonJS({
  "node_modules/web3/lib/solidity/dynamicbytes.js"(exports, module) {
    var f = require_formatters2();
    var SolidityType = require_type();
    var SolidityTypeDynamicBytes = function() {
      this._inputFormatter = f.formatInputDynamicBytes;
      this._outputFormatter = f.formatOutputDynamicBytes;
    };
    SolidityTypeDynamicBytes.prototype = new SolidityType({});
    SolidityTypeDynamicBytes.prototype.constructor = SolidityTypeDynamicBytes;
    SolidityTypeDynamicBytes.prototype.isType = function(name) {
      return !!name.match(/^bytes(\[([0-9]*)\])*$/);
    };
    SolidityTypeDynamicBytes.prototype.isDynamicType = function() {
      return true;
    };
    module.exports = SolidityTypeDynamicBytes;
  }
});

// node_modules/web3/lib/solidity/string.js
var require_string = __commonJS({
  "node_modules/web3/lib/solidity/string.js"(exports, module) {
    var f = require_formatters2();
    var SolidityType = require_type();
    var SolidityTypeString = function() {
      this._inputFormatter = f.formatInputString;
      this._outputFormatter = f.formatOutputString;
    };
    SolidityTypeString.prototype = new SolidityType({});
    SolidityTypeString.prototype.constructor = SolidityTypeString;
    SolidityTypeString.prototype.isType = function(name) {
      return !!name.match(/^string(\[([0-9]*)\])*$/);
    };
    SolidityTypeString.prototype.isDynamicType = function() {
      return true;
    };
    module.exports = SolidityTypeString;
  }
});

// node_modules/web3/lib/solidity/real.js
var require_real = __commonJS({
  "node_modules/web3/lib/solidity/real.js"(exports, module) {
    var f = require_formatters2();
    var SolidityType = require_type();
    var SolidityTypeReal = function() {
      this._inputFormatter = f.formatInputReal;
      this._outputFormatter = f.formatOutputReal;
    };
    SolidityTypeReal.prototype = new SolidityType({});
    SolidityTypeReal.prototype.constructor = SolidityTypeReal;
    SolidityTypeReal.prototype.isType = function(name) {
      return !!name.match(/real([0-9]*)?(\[([0-9]*)\])?/);
    };
    module.exports = SolidityTypeReal;
  }
});

// node_modules/web3/lib/solidity/ureal.js
var require_ureal = __commonJS({
  "node_modules/web3/lib/solidity/ureal.js"(exports, module) {
    var f = require_formatters2();
    var SolidityType = require_type();
    var SolidityTypeUReal = function() {
      this._inputFormatter = f.formatInputReal;
      this._outputFormatter = f.formatOutputUReal;
    };
    SolidityTypeUReal.prototype = new SolidityType({});
    SolidityTypeUReal.prototype.constructor = SolidityTypeUReal;
    SolidityTypeUReal.prototype.isType = function(name) {
      return !!name.match(/^ureal([0-9]*)?(\[([0-9]*)\])*$/);
    };
    module.exports = SolidityTypeUReal;
  }
});

// node_modules/web3/lib/solidity/bytes.js
var require_bytes = __commonJS({
  "node_modules/web3/lib/solidity/bytes.js"(exports, module) {
    var f = require_formatters2();
    var SolidityType = require_type();
    var SolidityTypeBytes = function() {
      this._inputFormatter = f.formatInputBytes;
      this._outputFormatter = f.formatOutputBytes;
    };
    SolidityTypeBytes.prototype = new SolidityType({});
    SolidityTypeBytes.prototype.constructor = SolidityTypeBytes;
    SolidityTypeBytes.prototype.isType = function(name) {
      return !!name.match(/^bytes([0-9]{1,})(\[([0-9]*)\])*$/);
    };
    module.exports = SolidityTypeBytes;
  }
});

// node_modules/web3/lib/solidity/coder.js
var require_coder = __commonJS({
  "node_modules/web3/lib/solidity/coder.js"(exports, module) {
    var f = require_formatters2();
    var SolidityTypeAddress = require_address();
    var SolidityTypeBool = require_bool();
    var SolidityTypeInt = require_int();
    var SolidityTypeUInt = require_uint();
    var SolidityTypeDynamicBytes = require_dynamicbytes();
    var SolidityTypeString = require_string();
    var SolidityTypeReal = require_real();
    var SolidityTypeUReal = require_ureal();
    var SolidityTypeBytes = require_bytes();
    var isDynamic = function(solidityType, type) {
      return solidityType.isDynamicType(type) || solidityType.isDynamicArray(type);
    };
    var SolidityCoder = function(types) {
      this._types = types;
    };
    SolidityCoder.prototype._requireType = function(type) {
      var solidityType = this._types.filter(function(t) {
        return t.isType(type);
      })[0];
      if (!solidityType) {
        throw Error("invalid solidity type!: " + type);
      }
      return solidityType;
    };
    SolidityCoder.prototype.encodeParam = function(type, param) {
      return this.encodeParams([type], [param]);
    };
    SolidityCoder.prototype.encodeParams = function(types, params) {
      var solidityTypes = this.getSolidityTypes(types);
      var encodeds = solidityTypes.map(function(solidityType, index) {
        return solidityType.encode(params[index], types[index]);
      });
      var dynamicOffset = solidityTypes.reduce(function(acc, solidityType, index) {
        var staticPartLength = solidityType.staticPartLength(types[index]);
        var roundedStaticPartLength = Math.floor((staticPartLength + 31) / 32) * 32;
        return acc + (isDynamic(solidityTypes[index], types[index]) ? 32 : roundedStaticPartLength);
      }, 0);
      var result = this.encodeMultiWithOffset(types, solidityTypes, encodeds, dynamicOffset);
      return result;
    };
    SolidityCoder.prototype.encodeMultiWithOffset = function(types, solidityTypes, encodeds, dynamicOffset) {
      var result = "";
      var self = this;
      types.forEach(function(type, i) {
        if (isDynamic(solidityTypes[i], types[i])) {
          result += f.formatInputInt(dynamicOffset).encode();
          var e = self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
          dynamicOffset += e.length / 2;
        } else {
          result += self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
        }
      });
      types.forEach(function(type, i) {
        if (isDynamic(solidityTypes[i], types[i])) {
          var e = self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
          dynamicOffset += e.length / 2;
          result += e;
        }
      });
      return result;
    };
    SolidityCoder.prototype.encodeWithOffset = function(type, solidityType, encoded, offset) {
      var self = this;
      var encodingMode = { dynamic: 1, static: 2, other: 3 };
      var mode = solidityType.isDynamicArray(type) ? encodingMode.dynamic : solidityType.isStaticArray(type) ? encodingMode.static : encodingMode.other;
      if (mode !== encodingMode.other) {
        var nestedName = solidityType.nestedName(type);
        var nestedStaticPartLength = solidityType.staticPartLength(nestedName);
        var result = mode === encodingMode.dynamic ? encoded[0] : "";
        if (solidityType.isDynamicArray(nestedName)) {
          var previousLength = mode === encodingMode.dynamic ? 2 : 0;
          for (var i = 0; i < encoded.length; i++) {
            if (mode === encodingMode.dynamic) {
              previousLength += +encoded[i - 1][0] || 0;
            } else if (mode === encodingMode.static) {
              previousLength += +(encoded[i - 1] || [])[0] || 0;
            }
            result += f.formatInputInt(offset + i * nestedStaticPartLength + previousLength * 32).encode();
          }
        }
        var len = mode === encodingMode.dynamic ? encoded.length - 1 : encoded.length;
        for (var c = 0; c < len; c++) {
          var additionalOffset = result / 2;
          if (mode === encodingMode.dynamic) {
            result += self.encodeWithOffset(nestedName, solidityType, encoded[c + 1], offset + additionalOffset);
          } else if (mode === encodingMode.static) {
            result += self.encodeWithOffset(nestedName, solidityType, encoded[c], offset + additionalOffset);
          }
        }
        return result;
      }
      return encoded;
    };
    SolidityCoder.prototype.decodeParam = function(type, bytes) {
      return this.decodeParams([type], bytes)[0];
    };
    SolidityCoder.prototype.decodeParams = function(types, bytes) {
      var solidityTypes = this.getSolidityTypes(types);
      var offsets = this.getOffsets(types, solidityTypes);
      return solidityTypes.map(function(solidityType, index) {
        return solidityType.decode(bytes, offsets[index], types[index], index);
      });
    };
    SolidityCoder.prototype.getOffsets = function(types, solidityTypes) {
      var lengths = solidityTypes.map(function(solidityType, index) {
        return solidityType.staticPartLength(types[index]);
      });
      for (var i = 1; i < lengths.length; i++) {
        lengths[i] += lengths[i - 1];
      }
      return lengths.map(function(length, index) {
        var staticPartLength = solidityTypes[index].staticPartLength(types[index]);
        return length - staticPartLength;
      });
    };
    SolidityCoder.prototype.getSolidityTypes = function(types) {
      var self = this;
      return types.map(function(type) {
        return self._requireType(type);
      });
    };
    var coder = new SolidityCoder([
      new SolidityTypeAddress(),
      new SolidityTypeBool(),
      new SolidityTypeInt(),
      new SolidityTypeUInt(),
      new SolidityTypeDynamicBytes(),
      new SolidityTypeBytes(),
      new SolidityTypeString(),
      new SolidityTypeReal(),
      new SolidityTypeUReal()
    ]);
    module.exports = coder;
  }
});

// node_modules/web3/lib/web3/filter.js
var require_filter = __commonJS({
  "node_modules/web3/lib/web3/filter.js"(exports, module) {
    var formatters = require_formatters();
    var utils = require_utils();
    var toTopic = function(value) {
      if (value === null || typeof value === "undefined")
        return null;
      value = String(value);
      if (value.indexOf("0x") === 0)
        return value;
      else
        return utils.fromUtf8(value);
    };
    var getOptions = function(options, type) {
      if (utils.isString(options)) {
        return options;
      }
      options = options || {};
      switch (type) {
        case "eth":
          options.topics = options.topics || [];
          options.topics = options.topics.map(function(topic) {
            return utils.isArray(topic) ? topic.map(toTopic) : toTopic(topic);
          });
          return {
            topics: options.topics,
            from: options.from,
            to: options.to,
            address: options.address,
            fromBlock: formatters.inputBlockNumberFormatter(options.fromBlock),
            toBlock: formatters.inputBlockNumberFormatter(options.toBlock)
          };
        case "shh":
          return options;
      }
    };
    var getLogsAtStart = function(self, callback) {
      if (!utils.isString(self.options)) {
        self.get(function(err, messages) {
          if (err) {
            callback(err);
          }
          if (utils.isArray(messages)) {
            messages.forEach(function(message) {
              callback(null, message);
            });
          }
        });
      }
    };
    var pollFilter = function(self) {
      var onMessage = function(error, messages) {
        if (error) {
          return self.callbacks.forEach(function(callback) {
            callback(error);
          });
        }
        if (utils.isArray(messages)) {
          messages.forEach(function(message) {
            message = self.formatter ? self.formatter(message) : message;
            self.callbacks.forEach(function(callback) {
              callback(null, message);
            });
          });
        }
      };
      self.requestManager.startPolling({
        method: self.implementation.poll.call,
        params: [self.filterId]
      }, self.filterId, onMessage, self.stopWatching.bind(self));
    };
    var Filter = function(options, type, requestManager, methods, formatter, callback, filterCreationErrorCallback) {
      var self = this;
      var implementation = {};
      methods.forEach(function(method) {
        method.setRequestManager(requestManager);
        method.attachToObject(implementation);
      });
      this.requestManager = requestManager;
      this.options = getOptions(options, type);
      this.implementation = implementation;
      this.filterId = null;
      this.callbacks = [];
      this.getLogsCallbacks = [];
      this.pollFilters = [];
      this.formatter = formatter;
      this.implementation.newFilter(this.options, function(error, id) {
        if (error) {
          self.callbacks.forEach(function(cb) {
            cb(error);
          });
          if (typeof filterCreationErrorCallback === "function") {
            filterCreationErrorCallback(error);
          }
        } else {
          self.filterId = id;
          self.getLogsCallbacks.forEach(function(cb) {
            self.get(cb);
          });
          self.getLogsCallbacks = [];
          self.callbacks.forEach(function(cb) {
            getLogsAtStart(self, cb);
          });
          if (self.callbacks.length > 0)
            pollFilter(self);
          if (typeof callback === "function") {
            return self.watch(callback);
          }
        }
      });
      return this;
    };
    Filter.prototype.watch = function(callback) {
      this.callbacks.push(callback);
      if (this.filterId) {
        getLogsAtStart(this, callback);
        pollFilter(this);
      }
      return this;
    };
    Filter.prototype.stopWatching = function(callback) {
      this.requestManager.stopPolling(this.filterId);
      this.callbacks = [];
      if (callback) {
        this.implementation.uninstallFilter(this.filterId, callback);
      } else {
        return this.implementation.uninstallFilter(this.filterId);
      }
    };
    Filter.prototype.get = function(callback) {
      var self = this;
      if (utils.isFunction(callback)) {
        if (this.filterId === null) {
          this.getLogsCallbacks.push(callback);
        } else {
          this.implementation.getLogs(this.filterId, function(err, res) {
            if (err) {
              callback(err);
            } else {
              callback(null, res.map(function(log) {
                return self.formatter ? self.formatter(log) : log;
              }));
            }
          });
        }
      } else {
        if (this.filterId === null) {
          throw new Error("Filter ID Error: filter().get() can't be chained synchronous, please provide a callback for the get() method.");
        }
        var logs = this.implementation.getLogs(this.filterId);
        return logs.map(function(log) {
          return self.formatter ? self.formatter(log) : log;
        });
      }
      return this;
    };
    module.exports = Filter;
  }
});

// node_modules/web3/lib/web3/methods/watches.js
var require_watches = __commonJS({
  "node_modules/web3/lib/web3/methods/watches.js"(exports, module) {
    var Method = require_method();
    var eth = function() {
      var newFilterCall = function(args) {
        var type = args[0];
        switch (type) {
          case "latest":
            args.shift();
            this.params = 0;
            return "eth_newBlockFilter";
          case "pending":
            args.shift();
            this.params = 0;
            return "eth_newPendingTransactionFilter";
          default:
            return "eth_newFilter";
        }
      };
      var newFilter = new Method({
        name: "newFilter",
        call: newFilterCall,
        params: 1
      });
      var uninstallFilter = new Method({
        name: "uninstallFilter",
        call: "eth_uninstallFilter",
        params: 1
      });
      var getLogs = new Method({
        name: "getLogs",
        call: "eth_getFilterLogs",
        params: 1
      });
      var poll = new Method({
        name: "poll",
        call: "eth_getFilterChanges",
        params: 1
      });
      return [
        newFilter,
        uninstallFilter,
        getLogs,
        poll
      ];
    };
    var shh = function() {
      return [
        new Method({
          name: "newFilter",
          call: "shh_newMessageFilter",
          params: 1
        }),
        new Method({
          name: "uninstallFilter",
          call: "shh_deleteMessageFilter",
          params: 1
        }),
        new Method({
          name: "getLogs",
          call: "shh_getFilterMessages",
          params: 1
        }),
        new Method({
          name: "poll",
          call: "shh_getFilterMessages",
          params: 1
        })
      ];
    };
    module.exports = {
      eth,
      shh
    };
  }
});

// node_modules/web3/lib/web3/event.js
var require_event = __commonJS({
  "node_modules/web3/lib/web3/event.js"(exports, module) {
    var utils = require_utils();
    var coder = require_coder();
    var formatters = require_formatters();
    var sha3 = require_sha32();
    var Filter = require_filter();
    var watches = require_watches();
    var SolidityEvent = function(requestManager, json, address) {
      this._requestManager = requestManager;
      this._params = json.inputs;
      this._name = utils.transformToFullName(json);
      this._address = address;
      this._anonymous = json.anonymous;
    };
    SolidityEvent.prototype.types = function(indexed) {
      return this._params.filter(function(i) {
        return i.indexed === indexed;
      }).map(function(i) {
        return i.type;
      });
    };
    SolidityEvent.prototype.displayName = function() {
      return utils.extractDisplayName(this._name);
    };
    SolidityEvent.prototype.typeName = function() {
      return utils.extractTypeName(this._name);
    };
    SolidityEvent.prototype.signature = function() {
      return sha3(this._name);
    };
    SolidityEvent.prototype.encode = function(indexed, options) {
      indexed = indexed || {};
      options = options || {};
      var result = {};
      ["fromBlock", "toBlock"].filter(function(f) {
        return options[f] !== void 0;
      }).forEach(function(f) {
        result[f] = formatters.inputBlockNumberFormatter(options[f]);
      });
      result.topics = [];
      result.address = this._address;
      if (!this._anonymous) {
        result.topics.push("0x" + this.signature());
      }
      var indexedTopics = this._params.filter(function(i) {
        return i.indexed === true;
      }).map(function(i) {
        var value = indexed[i.name];
        if (value === void 0 || value === null) {
          return null;
        }
        if (utils.isArray(value)) {
          return value.map(function(v) {
            return "0x" + coder.encodeParam(i.type, v);
          });
        }
        return "0x" + coder.encodeParam(i.type, value);
      });
      result.topics = result.topics.concat(indexedTopics);
      return result;
    };
    SolidityEvent.prototype.decode = function(data) {
      data.data = data.data || "";
      data.topics = data.topics || [];
      var argTopics = this._anonymous ? data.topics : data.topics.slice(1);
      var indexedData = argTopics.map(function(topics) {
        return topics.slice(2);
      }).join("");
      var indexedParams = coder.decodeParams(this.types(true), indexedData);
      var notIndexedData = data.data.slice(2);
      var notIndexedParams = coder.decodeParams(this.types(false), notIndexedData);
      var result = formatters.outputLogFormatter(data);
      result.event = this.displayName();
      result.address = data.address;
      result.args = this._params.reduce(function(acc, current) {
        acc[current.name] = current.indexed ? indexedParams.shift() : notIndexedParams.shift();
        return acc;
      }, {});
      delete result.data;
      delete result.topics;
      return result;
    };
    SolidityEvent.prototype.execute = function(indexed, options, callback) {
      if (utils.isFunction(arguments[arguments.length - 1])) {
        callback = arguments[arguments.length - 1];
        if (arguments.length === 2)
          options = null;
        if (arguments.length === 1) {
          options = null;
          indexed = {};
        }
      }
      var o = this.encode(indexed, options);
      var formatter = this.decode.bind(this);
      return new Filter(o, "eth", this._requestManager, watches.eth(), formatter, callback);
    };
    SolidityEvent.prototype.attachToContract = function(contract) {
      var execute = this.execute.bind(this);
      var displayName = this.displayName();
      if (!contract[displayName]) {
        contract[displayName] = execute;
      }
      contract[displayName][this.typeName()] = this.execute.bind(this, contract);
    };
    module.exports = SolidityEvent;
  }
});

// node_modules/web3/lib/web3/function.js
var require_function = __commonJS({
  "node_modules/web3/lib/web3/function.js"(exports, module) {
    var coder = require_coder();
    var utils = require_utils();
    var errors = require_errors();
    var formatters = require_formatters();
    var sha3 = require_sha32();
    var SolidityFunction = function(eth, json, address) {
      this._eth = eth;
      this._inputTypes = json.inputs.map(function(i) {
        return i.type;
      });
      this._outputTypes = json.outputs.map(function(i) {
        return i.type;
      });
      this._constant = json.stateMutability === "view" || json.stateMutability === "pure" || json.constant;
      this._payable = json.stateMutability === "payable" || json.payable;
      this._name = utils.transformToFullName(json);
      this._address = address;
    };
    SolidityFunction.prototype.extractCallback = function(args) {
      if (utils.isFunction(args[args.length - 1])) {
        return args.pop();
      }
    };
    SolidityFunction.prototype.extractDefaultBlock = function(args) {
      if (args.length > this._inputTypes.length && !utils.isObject(args[args.length - 1])) {
        return formatters.inputDefaultBlockNumberFormatter(args.pop());
      }
    };
    SolidityFunction.prototype.validateArgs = function(args) {
      var inputArgs = args.filter(function(a) {
        return !(utils.isObject(a) === true && utils.isArray(a) === false && utils.isBigNumber(a) === false);
      });
      if (inputArgs.length !== this._inputTypes.length) {
        throw errors.InvalidNumberOfSolidityArgs();
      }
    };
    SolidityFunction.prototype.toPayload = function(args) {
      var options = {};
      if (args.length > this._inputTypes.length && utils.isObject(args[args.length - 1])) {
        options = args[args.length - 1];
      }
      this.validateArgs(args);
      options.to = this._address;
      options.data = "0x" + this.signature() + coder.encodeParams(this._inputTypes, args);
      return options;
    };
    SolidityFunction.prototype.signature = function() {
      return sha3(this._name).slice(0, 8);
    };
    SolidityFunction.prototype.unpackOutput = function(output) {
      if (!output) {
        return;
      }
      output = output.length >= 2 ? output.slice(2) : output;
      var result = coder.decodeParams(this._outputTypes, output);
      return result.length === 1 ? result[0] : result;
    };
    SolidityFunction.prototype.call = function() {
      var args = Array.prototype.slice.call(arguments).filter(function(a) {
        return a !== void 0;
      });
      var callback = this.extractCallback(args);
      var defaultBlock = this.extractDefaultBlock(args);
      var payload = this.toPayload(args);
      if (!callback) {
        var output = this._eth.call(payload, defaultBlock);
        return this.unpackOutput(output);
      }
      var self = this;
      this._eth.call(payload, defaultBlock, function(error, output2) {
        if (error)
          return callback(error, null);
        var unpacked = null;
        try {
          unpacked = self.unpackOutput(output2);
        } catch (e) {
          error = e;
        }
        callback(error, unpacked);
      });
    };
    SolidityFunction.prototype.sendTransaction = function() {
      var args = Array.prototype.slice.call(arguments).filter(function(a) {
        return a !== void 0;
      });
      var callback = this.extractCallback(args);
      var payload = this.toPayload(args);
      if (payload.value > 0 && !this._payable) {
        throw new Error("Cannot send value to non-payable function");
      }
      if (!callback) {
        return this._eth.sendTransaction(payload);
      }
      this._eth.sendTransaction(payload, callback);
    };
    SolidityFunction.prototype.estimateGas = function() {
      var args = Array.prototype.slice.call(arguments);
      var callback = this.extractCallback(args);
      var payload = this.toPayload(args);
      if (!callback) {
        return this._eth.estimateGas(payload);
      }
      this._eth.estimateGas(payload, callback);
    };
    SolidityFunction.prototype.getData = function() {
      var args = Array.prototype.slice.call(arguments);
      var payload = this.toPayload(args);
      return payload.data;
    };
    SolidityFunction.prototype.displayName = function() {
      return utils.extractDisplayName(this._name);
    };
    SolidityFunction.prototype.typeName = function() {
      return utils.extractTypeName(this._name);
    };
    SolidityFunction.prototype.request = function() {
      var args = Array.prototype.slice.call(arguments);
      var callback = this.extractCallback(args);
      var payload = this.toPayload(args);
      var format = this.unpackOutput.bind(this);
      return {
        method: this._constant ? "eth_call" : "eth_sendTransaction",
        callback,
        params: [payload],
        format
      };
    };
    SolidityFunction.prototype.execute = function() {
      var transaction = !this._constant;
      if (transaction) {
        return this.sendTransaction.apply(this, Array.prototype.slice.call(arguments));
      }
      return this.call.apply(this, Array.prototype.slice.call(arguments));
    };
    SolidityFunction.prototype.attachToContract = function(contract) {
      var execute = this.execute.bind(this);
      execute.request = this.request.bind(this);
      execute.call = this.call.bind(this);
      execute.sendTransaction = this.sendTransaction.bind(this);
      execute.estimateGas = this.estimateGas.bind(this);
      execute.getData = this.getData.bind(this);
      var displayName = this.displayName();
      if (!contract[displayName]) {
        contract[displayName] = execute;
      }
      contract[displayName][this.typeName()] = execute;
    };
    module.exports = SolidityFunction;
  }
});

// node_modules/web3/lib/web3/allevents.js
var require_allevents = __commonJS({
  "node_modules/web3/lib/web3/allevents.js"(exports, module) {
    var sha3 = require_sha32();
    var SolidityEvent = require_event();
    var formatters = require_formatters();
    var utils = require_utils();
    var Filter = require_filter();
    var watches = require_watches();
    var AllSolidityEvents = function(requestManager, json, address) {
      this._requestManager = requestManager;
      this._json = json;
      this._address = address;
    };
    AllSolidityEvents.prototype.encode = function(options) {
      options = options || {};
      var result = {};
      ["fromBlock", "toBlock"].filter(function(f) {
        return options[f] !== void 0;
      }).forEach(function(f) {
        result[f] = formatters.inputBlockNumberFormatter(options[f]);
      });
      result.address = this._address;
      return result;
    };
    AllSolidityEvents.prototype.decode = function(data) {
      data.data = data.data || "";
      var eventTopic = utils.isArray(data.topics) && utils.isString(data.topics[0]) ? data.topics[0].slice(2) : "";
      var match = this._json.filter(function(j) {
        return eventTopic === sha3(utils.transformToFullName(j));
      })[0];
      if (!match) {
        return formatters.outputLogFormatter(data);
      }
      var event = new SolidityEvent(this._requestManager, match, this._address);
      return event.decode(data);
    };
    AllSolidityEvents.prototype.execute = function(options, callback) {
      if (utils.isFunction(arguments[arguments.length - 1])) {
        callback = arguments[arguments.length - 1];
        if (arguments.length === 1)
          options = null;
      }
      var o = this.encode(options);
      var formatter = this.decode.bind(this);
      return new Filter(o, "eth", this._requestManager, watches.eth(), formatter, callback);
    };
    AllSolidityEvents.prototype.attachToContract = function(contract) {
      var execute = this.execute.bind(this);
      contract.allEvents = execute;
    };
    module.exports = AllSolidityEvents;
  }
});

// node_modules/web3/lib/web3/contract.js
var require_contract = __commonJS({
  "node_modules/web3/lib/web3/contract.js"(exports, module) {
    var utils = require_utils();
    var coder = require_coder();
    var SolidityEvent = require_event();
    var SolidityFunction = require_function();
    var AllEvents = require_allevents();
    var encodeConstructorParams = function(abi, params) {
      return abi.filter(function(json) {
        return json.type === "constructor" && json.inputs.length === params.length;
      }).map(function(json) {
        return json.inputs.map(function(input) {
          return input.type;
        });
      }).map(function(types) {
        return coder.encodeParams(types, params);
      })[0] || "";
    };
    var addFunctionsToContract = function(contract) {
      contract.abi.filter(function(json) {
        return json.type === "function";
      }).map(function(json) {
        return new SolidityFunction(contract._eth, json, contract.address);
      }).forEach(function(f) {
        f.attachToContract(contract);
      });
    };
    var addEventsToContract = function(contract) {
      var events = contract.abi.filter(function(json) {
        return json.type === "event";
      });
      var All = new AllEvents(contract._eth._requestManager, events, contract.address);
      All.attachToContract(contract);
      events.map(function(json) {
        return new SolidityEvent(contract._eth._requestManager, json, contract.address);
      }).forEach(function(e) {
        e.attachToContract(contract);
      });
    };
    var checkForContractAddress = function(contract, callback) {
      var count = 0, callbackFired = false;
      var filter = contract._eth.filter("latest", function(e) {
        if (!e && !callbackFired) {
          count++;
          if (count > 50) {
            filter.stopWatching(function() {
            });
            callbackFired = true;
            if (callback)
              callback(new Error("Contract transaction couldn't be found after 50 blocks"));
            else
              throw new Error("Contract transaction couldn't be found after 50 blocks");
          } else {
            contract._eth.getTransactionReceipt(contract.transactionHash, function(e2, receipt) {
              if (receipt && receipt.blockHash && !callbackFired) {
                contract._eth.getCode(receipt.contractAddress, function(e3, code) {
                  if (callbackFired || !code)
                    return;
                  filter.stopWatching(function() {
                  });
                  callbackFired = true;
                  if (code.length > 3) {
                    contract.address = receipt.contractAddress;
                    addFunctionsToContract(contract);
                    addEventsToContract(contract);
                    if (callback)
                      callback(null, contract);
                  } else {
                    if (callback)
                      callback(new Error("The contract code couldn't be stored, please check your gas amount."));
                    else
                      throw new Error("The contract code couldn't be stored, please check your gas amount.");
                  }
                });
              }
            });
          }
        }
      });
    };
    var ContractFactory = function(eth, abi) {
      this.eth = eth;
      this.abi = abi;
      this.new = function() {
        var contract = new Contract(this.eth, this.abi);
        var options = {};
        var callback;
        var args = Array.prototype.slice.call(arguments);
        if (utils.isFunction(args[args.length - 1])) {
          callback = args.pop();
        }
        var last = args[args.length - 1];
        if (utils.isObject(last) && !utils.isArray(last)) {
          options = args.pop();
        }
        if (options.value > 0) {
          var constructorAbi = abi.filter(function(json) {
            return json.type === "constructor" && json.inputs.length === args.length;
          })[0] || {};
          if (!constructorAbi.payable) {
            throw new Error("Cannot send value to non-payable constructor");
          }
        }
        var bytes = encodeConstructorParams(this.abi, args);
        options.data += bytes;
        if (callback) {
          this.eth.sendTransaction(options, function(err, hash2) {
            if (err) {
              callback(err);
            } else {
              contract.transactionHash = hash2;
              callback(null, contract);
              checkForContractAddress(contract, callback);
            }
          });
        } else {
          var hash = this.eth.sendTransaction(options);
          contract.transactionHash = hash;
          checkForContractAddress(contract);
        }
        return contract;
      };
      this.new.getData = this.getData.bind(this);
    };
    ContractFactory.prototype.at = function(address, callback) {
      var contract = new Contract(this.eth, this.abi, address);
      addFunctionsToContract(contract);
      addEventsToContract(contract);
      if (callback) {
        callback(null, contract);
      }
      return contract;
    };
    ContractFactory.prototype.getData = function() {
      var options = {};
      var args = Array.prototype.slice.call(arguments);
      var last = args[args.length - 1];
      if (utils.isObject(last) && !utils.isArray(last)) {
        options = args.pop();
      }
      var bytes = encodeConstructorParams(this.abi, args);
      options.data += bytes;
      return options.data;
    };
    var Contract = function(eth, abi, address) {
      this._eth = eth;
      this.transactionHash = null;
      this.address = address;
      this.abi = abi;
    };
    module.exports = ContractFactory;
  }
});

// node_modules/web3/lib/web3/syncing.js
var require_syncing = __commonJS({
  "node_modules/web3/lib/web3/syncing.js"(exports, module) {
    var formatters = require_formatters();
    var utils = require_utils();
    var count = 1;
    var pollSyncing = function(self) {
      var onMessage = function(error, sync) {
        if (error) {
          return self.callbacks.forEach(function(callback) {
            callback(error);
          });
        }
        if (utils.isObject(sync) && sync.startingBlock)
          sync = formatters.outputSyncingFormatter(sync);
        self.callbacks.forEach(function(callback) {
          if (self.lastSyncState !== sync) {
            if (!self.lastSyncState && utils.isObject(sync))
              callback(null, true);
            setTimeout(function() {
              callback(null, sync);
            }, 0);
            self.lastSyncState = sync;
          }
        });
      };
      self.requestManager.startPolling({
        method: "eth_syncing",
        params: []
      }, self.pollId, onMessage, self.stopWatching.bind(self));
    };
    var IsSyncing = function(requestManager, callback) {
      this.requestManager = requestManager;
      this.pollId = "syncPoll_" + count++;
      this.callbacks = [];
      this.addCallback(callback);
      this.lastSyncState = false;
      pollSyncing(this);
      return this;
    };
    IsSyncing.prototype.addCallback = function(callback) {
      if (callback)
        this.callbacks.push(callback);
      return this;
    };
    IsSyncing.prototype.stopWatching = function() {
      this.requestManager.stopPolling(this.pollId);
      this.callbacks = [];
    };
    module.exports = IsSyncing;
  }
});

// node_modules/web3/lib/contracts/GlobalRegistrar.json
var require_GlobalRegistrar = __commonJS({
  "node_modules/web3/lib/contracts/GlobalRegistrar.json"(exports, module) {
    module.exports = [
      {
        constant: true,
        inputs: [
          {
            name: "_owner",
            type: "address"
          }
        ],
        name: "name",
        outputs: [
          {
            name: "o_name",
            type: "bytes32"
          }
        ],
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            name: "_name",
            type: "bytes32"
          }
        ],
        name: "owner",
        outputs: [
          {
            name: "",
            type: "address"
          }
        ],
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            name: "_name",
            type: "bytes32"
          }
        ],
        name: "content",
        outputs: [
          {
            name: "",
            type: "bytes32"
          }
        ],
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            name: "_name",
            type: "bytes32"
          }
        ],
        name: "addr",
        outputs: [
          {
            name: "",
            type: "address"
          }
        ],
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_name",
            type: "bytes32"
          }
        ],
        name: "reserve",
        outputs: [],
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            name: "_name",
            type: "bytes32"
          }
        ],
        name: "subRegistrar",
        outputs: [
          {
            name: "",
            type: "address"
          }
        ],
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_name",
            type: "bytes32"
          },
          {
            name: "_newOwner",
            type: "address"
          }
        ],
        name: "transfer",
        outputs: [],
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_name",
            type: "bytes32"
          },
          {
            name: "_registrar",
            type: "address"
          }
        ],
        name: "setSubRegistrar",
        outputs: [],
        type: "function"
      },
      {
        constant: false,
        inputs: [],
        name: "Registrar",
        outputs: [],
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_name",
            type: "bytes32"
          },
          {
            name: "_a",
            type: "address"
          },
          {
            name: "_primary",
            type: "bool"
          }
        ],
        name: "setAddress",
        outputs: [],
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_name",
            type: "bytes32"
          },
          {
            name: "_content",
            type: "bytes32"
          }
        ],
        name: "setContent",
        outputs: [],
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_name",
            type: "bytes32"
          }
        ],
        name: "disown",
        outputs: [],
        type: "function"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            name: "_name",
            type: "bytes32"
          },
          {
            indexed: false,
            name: "_winner",
            type: "address"
          }
        ],
        name: "AuctionEnded",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            name: "_name",
            type: "bytes32"
          },
          {
            indexed: false,
            name: "_bidder",
            type: "address"
          },
          {
            indexed: false,
            name: "_value",
            type: "uint256"
          }
        ],
        name: "NewBid",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            name: "name",
            type: "bytes32"
          }
        ],
        name: "Changed",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            name: "name",
            type: "bytes32"
          },
          {
            indexed: true,
            name: "addr",
            type: "address"
          }
        ],
        name: "PrimaryChanged",
        type: "event"
      }
    ];
  }
});

// node_modules/web3/lib/contracts/ICAPRegistrar.json
var require_ICAPRegistrar = __commonJS({
  "node_modules/web3/lib/contracts/ICAPRegistrar.json"(exports, module) {
    module.exports = [
      {
        constant: true,
        inputs: [
          {
            name: "_name",
            type: "bytes32"
          }
        ],
        name: "owner",
        outputs: [
          {
            name: "",
            type: "address"
          }
        ],
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_name",
            type: "bytes32"
          },
          {
            name: "_refund",
            type: "address"
          }
        ],
        name: "disown",
        outputs: [],
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            name: "_name",
            type: "bytes32"
          }
        ],
        name: "addr",
        outputs: [
          {
            name: "",
            type: "address"
          }
        ],
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_name",
            type: "bytes32"
          }
        ],
        name: "reserve",
        outputs: [],
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_name",
            type: "bytes32"
          },
          {
            name: "_newOwner",
            type: "address"
          }
        ],
        name: "transfer",
        outputs: [],
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_name",
            type: "bytes32"
          },
          {
            name: "_a",
            type: "address"
          }
        ],
        name: "setAddr",
        outputs: [],
        type: "function"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            name: "name",
            type: "bytes32"
          }
        ],
        name: "Changed",
        type: "event"
      }
    ];
  }
});

// node_modules/web3/lib/web3/namereg.js
var require_namereg = __commonJS({
  "node_modules/web3/lib/web3/namereg.js"(exports, module) {
    var globalRegistrarAbi = require_GlobalRegistrar();
    var icapRegistrarAbi = require_ICAPRegistrar();
    var globalNameregAddress = "0xc6d9d2cd449a754c494264e1809c50e34d64562b";
    var icapNameregAddress = "0xa1a111bc074c9cfa781f0c38e63bd51c91b8af00";
    module.exports = {
      global: {
        abi: globalRegistrarAbi,
        address: globalNameregAddress
      },
      icap: {
        abi: icapRegistrarAbi,
        address: icapNameregAddress
      }
    };
  }
});

// node_modules/web3/lib/contracts/SmartExchange.json
var require_SmartExchange = __commonJS({
  "node_modules/web3/lib/contracts/SmartExchange.json"(exports, module) {
    module.exports = [
      {
        constant: false,
        inputs: [
          {
            name: "from",
            type: "bytes32"
          },
          {
            name: "to",
            type: "address"
          },
          {
            name: "value",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [],
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "from",
            type: "bytes32"
          },
          {
            name: "to",
            type: "address"
          },
          {
            name: "indirectId",
            type: "bytes32"
          },
          {
            name: "value",
            type: "uint256"
          }
        ],
        name: "icapTransfer",
        outputs: [],
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "to",
            type: "bytes32"
          }
        ],
        name: "deposit",
        outputs: [],
        payable: true,
        type: "function"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            name: "from",
            type: "address"
          },
          {
            indexed: false,
            name: "value",
            type: "uint256"
          }
        ],
        name: "AnonymousDeposit",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            name: "to",
            type: "bytes32"
          },
          {
            indexed: false,
            name: "value",
            type: "uint256"
          }
        ],
        name: "Deposit",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            name: "from",
            type: "bytes32"
          },
          {
            indexed: true,
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            name: "from",
            type: "bytes32"
          },
          {
            indexed: true,
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            name: "indirectId",
            type: "bytes32"
          },
          {
            indexed: false,
            name: "value",
            type: "uint256"
          }
        ],
        name: "IcapTransfer",
        type: "event"
      }
    ];
  }
});

// node_modules/web3/lib/web3/transfer.js
var require_transfer = __commonJS({
  "node_modules/web3/lib/web3/transfer.js"(exports, module) {
    var Iban = require_iban();
    var exchangeAbi = require_SmartExchange();
    var transfer = function(eth, from, to, value, callback) {
      var iban = new Iban(to);
      if (!iban.isValid()) {
        throw new Error("invalid iban address");
      }
      if (iban.isDirect()) {
        return transferToAddress(eth, from, iban.address(), value, callback);
      }
      if (!callback) {
        var address = eth.icapNamereg().addr(iban.institution());
        return deposit(eth, from, address, value, iban.client());
      }
      eth.icapNamereg().addr(iban.institution(), function(err, address2) {
        return deposit(eth, from, address2, value, iban.client(), callback);
      });
    };
    var transferToAddress = function(eth, from, to, value, callback) {
      return eth.sendTransaction({
        address: to,
        from,
        value
      }, callback);
    };
    var deposit = function(eth, from, to, value, client, callback) {
      var abi = exchangeAbi;
      return eth.contract(abi).at(to).deposit(client, {
        from,
        value
      }, callback);
    };
    module.exports = transfer;
  }
});

// node_modules/web3/lib/web3/methods/eth.js
var require_eth = __commonJS({
  "node_modules/web3/lib/web3/methods/eth.js"(exports, module) {
    "use strict";
    var formatters = require_formatters();
    var utils = require_utils();
    var Method = require_method();
    var Property = require_property();
    var c = require_config();
    var Contract = require_contract();
    var watches = require_watches();
    var Filter = require_filter();
    var IsSyncing = require_syncing();
    var namereg = require_namereg();
    var Iban = require_iban();
    var transfer = require_transfer();
    var blockCall = function(args) {
      return utils.isString(args[0]) && args[0].indexOf("0x") === 0 ? "eth_getBlockByHash" : "eth_getBlockByNumber";
    };
    var transactionFromBlockCall = function(args) {
      return utils.isString(args[0]) && args[0].indexOf("0x") === 0 ? "eth_getTransactionByBlockHashAndIndex" : "eth_getTransactionByBlockNumberAndIndex";
    };
    var uncleCall = function(args) {
      return utils.isString(args[0]) && args[0].indexOf("0x") === 0 ? "eth_getUncleByBlockHashAndIndex" : "eth_getUncleByBlockNumberAndIndex";
    };
    var getBlockTransactionCountCall = function(args) {
      return utils.isString(args[0]) && args[0].indexOf("0x") === 0 ? "eth_getBlockTransactionCountByHash" : "eth_getBlockTransactionCountByNumber";
    };
    var uncleCountCall = function(args) {
      return utils.isString(args[0]) && args[0].indexOf("0x") === 0 ? "eth_getUncleCountByBlockHash" : "eth_getUncleCountByBlockNumber";
    };
    function Eth(web3) {
      this._requestManager = web3._requestManager;
      var self = this;
      methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
      });
      properties().forEach(function(p) {
        p.attachToObject(self);
        p.setRequestManager(self._requestManager);
      });
      this.iban = Iban;
      this.sendIBANTransaction = transfer.bind(null, this);
    }
    Object.defineProperty(Eth.prototype, "defaultBlock", {
      get: function() {
        return c.defaultBlock;
      },
      set: function(val) {
        c.defaultBlock = val;
        return val;
      }
    });
    Object.defineProperty(Eth.prototype, "defaultAccount", {
      get: function() {
        return c.defaultAccount;
      },
      set: function(val) {
        c.defaultAccount = val;
        return val;
      }
    });
    var methods = function() {
      var getBalance = new Method({
        name: "getBalance",
        call: "eth_getBalance",
        params: 2,
        inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter],
        outputFormatter: formatters.outputBigNumberFormatter
      });
      var getStorageAt = new Method({
        name: "getStorageAt",
        call: "eth_getStorageAt",
        params: 3,
        inputFormatter: [null, utils.toHex, formatters.inputDefaultBlockNumberFormatter]
      });
      var getCode = new Method({
        name: "getCode",
        call: "eth_getCode",
        params: 2,
        inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]
      });
      var getBlock = new Method({
        name: "getBlock",
        call: blockCall,
        params: 2,
        inputFormatter: [formatters.inputBlockNumberFormatter, function(val) {
          return !!val;
        }],
        outputFormatter: formatters.outputBlockFormatter
      });
      var getUncle = new Method({
        name: "getUncle",
        call: uncleCall,
        params: 2,
        inputFormatter: [formatters.inputBlockNumberFormatter, utils.toHex],
        outputFormatter: formatters.outputBlockFormatter
      });
      var getCompilers = new Method({
        name: "getCompilers",
        call: "eth_getCompilers",
        params: 0
      });
      var getBlockTransactionCount = new Method({
        name: "getBlockTransactionCount",
        call: getBlockTransactionCountCall,
        params: 1,
        inputFormatter: [formatters.inputBlockNumberFormatter],
        outputFormatter: utils.toDecimal
      });
      var getBlockUncleCount = new Method({
        name: "getBlockUncleCount",
        call: uncleCountCall,
        params: 1,
        inputFormatter: [formatters.inputBlockNumberFormatter],
        outputFormatter: utils.toDecimal
      });
      var getTransaction = new Method({
        name: "getTransaction",
        call: "eth_getTransactionByHash",
        params: 1,
        outputFormatter: formatters.outputTransactionFormatter
      });
      var getTransactionFromBlock = new Method({
        name: "getTransactionFromBlock",
        call: transactionFromBlockCall,
        params: 2,
        inputFormatter: [formatters.inputBlockNumberFormatter, utils.toHex],
        outputFormatter: formatters.outputTransactionFormatter
      });
      var getTransactionReceipt = new Method({
        name: "getTransactionReceipt",
        call: "eth_getTransactionReceipt",
        params: 1,
        outputFormatter: formatters.outputTransactionReceiptFormatter
      });
      var getTransactionCount = new Method({
        name: "getTransactionCount",
        call: "eth_getTransactionCount",
        params: 2,
        inputFormatter: [null, formatters.inputDefaultBlockNumberFormatter],
        outputFormatter: utils.toDecimal
      });
      var sendRawTransaction = new Method({
        name: "sendRawTransaction",
        call: "eth_sendRawTransaction",
        params: 1,
        inputFormatter: [null]
      });
      var sendTransaction = new Method({
        name: "sendTransaction",
        call: "eth_sendTransaction",
        params: 1,
        inputFormatter: [formatters.inputTransactionFormatter]
      });
      var signTransaction = new Method({
        name: "signTransaction",
        call: "eth_signTransaction",
        params: 1,
        inputFormatter: [formatters.inputTransactionFormatter]
      });
      var sign = new Method({
        name: "sign",
        call: "eth_sign",
        params: 2,
        inputFormatter: [formatters.inputAddressFormatter, null]
      });
      var call = new Method({
        name: "call",
        call: "eth_call",
        params: 2,
        inputFormatter: [formatters.inputCallFormatter, formatters.inputDefaultBlockNumberFormatter]
      });
      var estimateGas = new Method({
        name: "estimateGas",
        call: "eth_estimateGas",
        params: 1,
        inputFormatter: [formatters.inputCallFormatter],
        outputFormatter: utils.toDecimal
      });
      var compileSolidity = new Method({
        name: "compile.solidity",
        call: "eth_compileSolidity",
        params: 1
      });
      var compileLLL = new Method({
        name: "compile.lll",
        call: "eth_compileLLL",
        params: 1
      });
      var compileSerpent = new Method({
        name: "compile.serpent",
        call: "eth_compileSerpent",
        params: 1
      });
      var submitWork = new Method({
        name: "submitWork",
        call: "eth_submitWork",
        params: 3
      });
      var getWork = new Method({
        name: "getWork",
        call: "eth_getWork",
        params: 0
      });
      return [
        getBalance,
        getStorageAt,
        getCode,
        getBlock,
        getUncle,
        getCompilers,
        getBlockTransactionCount,
        getBlockUncleCount,
        getTransaction,
        getTransactionFromBlock,
        getTransactionReceipt,
        getTransactionCount,
        call,
        estimateGas,
        sendRawTransaction,
        signTransaction,
        sendTransaction,
        sign,
        compileSolidity,
        compileLLL,
        compileSerpent,
        submitWork,
        getWork
      ];
    };
    var properties = function() {
      return [
        new Property({
          name: "coinbase",
          getter: "eth_coinbase"
        }),
        new Property({
          name: "mining",
          getter: "eth_mining"
        }),
        new Property({
          name: "hashrate",
          getter: "eth_hashrate",
          outputFormatter: utils.toDecimal
        }),
        new Property({
          name: "syncing",
          getter: "eth_syncing",
          outputFormatter: formatters.outputSyncingFormatter
        }),
        new Property({
          name: "gasPrice",
          getter: "eth_gasPrice",
          outputFormatter: formatters.outputBigNumberFormatter
        }),
        new Property({
          name: "accounts",
          getter: "eth_accounts"
        }),
        new Property({
          name: "blockNumber",
          getter: "eth_blockNumber",
          outputFormatter: utils.toDecimal
        }),
        new Property({
          name: "protocolVersion",
          getter: "eth_protocolVersion"
        })
      ];
    };
    Eth.prototype.contract = function(abi) {
      var factory = new Contract(this, abi);
      return factory;
    };
    Eth.prototype.filter = function(options, callback, filterCreationErrorCallback) {
      return new Filter(options, "eth", this._requestManager, watches.eth(), formatters.outputLogFormatter, callback, filterCreationErrorCallback);
    };
    Eth.prototype.namereg = function() {
      return this.contract(namereg.global.abi).at(namereg.global.address);
    };
    Eth.prototype.icapNamereg = function() {
      return this.contract(namereg.icap.abi).at(namereg.icap.address);
    };
    Eth.prototype.isSyncing = function(callback) {
      return new IsSyncing(this._requestManager, callback);
    };
    module.exports = Eth;
  }
});

// node_modules/web3/lib/web3/methods/db.js
var require_db = __commonJS({
  "node_modules/web3/lib/web3/methods/db.js"(exports, module) {
    var Method = require_method();
    var DB = function(web3) {
      this._requestManager = web3._requestManager;
      var self = this;
      methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(web3._requestManager);
      });
    };
    var methods = function() {
      var putString = new Method({
        name: "putString",
        call: "db_putString",
        params: 3
      });
      var getString = new Method({
        name: "getString",
        call: "db_getString",
        params: 2
      });
      var putHex = new Method({
        name: "putHex",
        call: "db_putHex",
        params: 3
      });
      var getHex = new Method({
        name: "getHex",
        call: "db_getHex",
        params: 2
      });
      return [
        putString,
        getString,
        putHex,
        getHex
      ];
    };
    module.exports = DB;
  }
});

// node_modules/web3/lib/web3/methods/shh.js
var require_shh = __commonJS({
  "node_modules/web3/lib/web3/methods/shh.js"(exports, module) {
    var Method = require_method();
    var Filter = require_filter();
    var watches = require_watches();
    var Shh = function(web3) {
      this._requestManager = web3._requestManager;
      var self = this;
      methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
      });
    };
    Shh.prototype.newMessageFilter = function(options, callback, filterCreationErrorCallback) {
      return new Filter(options, "shh", this._requestManager, watches.shh(), null, callback, filterCreationErrorCallback);
    };
    var methods = function() {
      return [
        new Method({
          name: "version",
          call: "shh_version",
          params: 0
        }),
        new Method({
          name: "info",
          call: "shh_info",
          params: 0
        }),
        new Method({
          name: "setMaxMessageSize",
          call: "shh_setMaxMessageSize",
          params: 1
        }),
        new Method({
          name: "setMinPoW",
          call: "shh_setMinPoW",
          params: 1
        }),
        new Method({
          name: "markTrustedPeer",
          call: "shh_markTrustedPeer",
          params: 1
        }),
        new Method({
          name: "newKeyPair",
          call: "shh_newKeyPair",
          params: 0
        }),
        new Method({
          name: "addPrivateKey",
          call: "shh_addPrivateKey",
          params: 1
        }),
        new Method({
          name: "deleteKeyPair",
          call: "shh_deleteKeyPair",
          params: 1
        }),
        new Method({
          name: "hasKeyPair",
          call: "shh_hasKeyPair",
          params: 1
        }),
        new Method({
          name: "getPublicKey",
          call: "shh_getPublicKey",
          params: 1
        }),
        new Method({
          name: "getPrivateKey",
          call: "shh_getPrivateKey",
          params: 1
        }),
        new Method({
          name: "newSymKey",
          call: "shh_newSymKey",
          params: 0
        }),
        new Method({
          name: "addSymKey",
          call: "shh_addSymKey",
          params: 1
        }),
        new Method({
          name: "generateSymKeyFromPassword",
          call: "shh_generateSymKeyFromPassword",
          params: 1
        }),
        new Method({
          name: "hasSymKey",
          call: "shh_hasSymKey",
          params: 1
        }),
        new Method({
          name: "getSymKey",
          call: "shh_getSymKey",
          params: 1
        }),
        new Method({
          name: "deleteSymKey",
          call: "shh_deleteSymKey",
          params: 1
        }),
        // subscribe and unsubscribe missing
        new Method({
          name: "post",
          call: "shh_post",
          params: 1,
          inputFormatter: [null]
        })
      ];
    };
    module.exports = Shh;
  }
});

// node_modules/web3/lib/web3/methods/net.js
var require_net = __commonJS({
  "node_modules/web3/lib/web3/methods/net.js"(exports, module) {
    var utils = require_utils();
    var Property = require_property();
    var Net = function(web3) {
      this._requestManager = web3._requestManager;
      var self = this;
      properties().forEach(function(p) {
        p.attachToObject(self);
        p.setRequestManager(web3._requestManager);
      });
    };
    var properties = function() {
      return [
        new Property({
          name: "listening",
          getter: "net_listening"
        }),
        new Property({
          name: "peerCount",
          getter: "net_peerCount",
          outputFormatter: utils.toDecimal
        })
      ];
    };
    module.exports = Net;
  }
});

// node_modules/web3/lib/web3/methods/personal.js
var require_personal = __commonJS({
  "node_modules/web3/lib/web3/methods/personal.js"(exports, module) {
    "use strict";
    var Method = require_method();
    var Property = require_property();
    var formatters = require_formatters();
    function Personal(web3) {
      this._requestManager = web3._requestManager;
      var self = this;
      methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
      });
      properties().forEach(function(p) {
        p.attachToObject(self);
        p.setRequestManager(self._requestManager);
      });
    }
    var methods = function() {
      var newAccount = new Method({
        name: "newAccount",
        call: "personal_newAccount",
        params: 1,
        inputFormatter: [null]
      });
      var importRawKey = new Method({
        name: "importRawKey",
        call: "personal_importRawKey",
        params: 2
      });
      var sign = new Method({
        name: "sign",
        call: "personal_sign",
        params: 3,
        inputFormatter: [null, formatters.inputAddressFormatter, null]
      });
      var ecRecover = new Method({
        name: "ecRecover",
        call: "personal_ecRecover",
        params: 2
      });
      var unlockAccount = new Method({
        name: "unlockAccount",
        call: "personal_unlockAccount",
        params: 3,
        inputFormatter: [formatters.inputAddressFormatter, null, null]
      });
      var sendTransaction = new Method({
        name: "sendTransaction",
        call: "personal_sendTransaction",
        params: 2,
        inputFormatter: [formatters.inputTransactionFormatter, null]
      });
      var lockAccount = new Method({
        name: "lockAccount",
        call: "personal_lockAccount",
        params: 1,
        inputFormatter: [formatters.inputAddressFormatter]
      });
      return [
        newAccount,
        importRawKey,
        unlockAccount,
        ecRecover,
        sign,
        sendTransaction,
        lockAccount
      ];
    };
    var properties = function() {
      return [
        new Property({
          name: "listAccounts",
          getter: "personal_listAccounts"
        })
      ];
    };
    module.exports = Personal;
  }
});

// node_modules/web3/lib/web3/methods/swarm.js
var require_swarm = __commonJS({
  "node_modules/web3/lib/web3/methods/swarm.js"(exports, module) {
    "use strict";
    var Method = require_method();
    var Property = require_property();
    function Swarm(web3) {
      this._requestManager = web3._requestManager;
      var self = this;
      methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
      });
      properties().forEach(function(p) {
        p.attachToObject(self);
        p.setRequestManager(self._requestManager);
      });
    }
    var methods = function() {
      var blockNetworkRead = new Method({
        name: "blockNetworkRead",
        call: "bzz_blockNetworkRead",
        params: 1,
        inputFormatter: [null]
      });
      var syncEnabled = new Method({
        name: "syncEnabled",
        call: "bzz_syncEnabled",
        params: 1,
        inputFormatter: [null]
      });
      var swapEnabled = new Method({
        name: "swapEnabled",
        call: "bzz_swapEnabled",
        params: 1,
        inputFormatter: [null]
      });
      var download = new Method({
        name: "download",
        call: "bzz_download",
        params: 2,
        inputFormatter: [null, null]
      });
      var upload = new Method({
        name: "upload",
        call: "bzz_upload",
        params: 2,
        inputFormatter: [null, null]
      });
      var retrieve = new Method({
        name: "retrieve",
        call: "bzz_retrieve",
        params: 1,
        inputFormatter: [null]
      });
      var store = new Method({
        name: "store",
        call: "bzz_store",
        params: 2,
        inputFormatter: [null, null]
      });
      var get = new Method({
        name: "get",
        call: "bzz_get",
        params: 1,
        inputFormatter: [null]
      });
      var put = new Method({
        name: "put",
        call: "bzz_put",
        params: 2,
        inputFormatter: [null, null]
      });
      var modify = new Method({
        name: "modify",
        call: "bzz_modify",
        params: 4,
        inputFormatter: [null, null, null, null]
      });
      return [
        blockNetworkRead,
        syncEnabled,
        swapEnabled,
        download,
        upload,
        retrieve,
        store,
        get,
        put,
        modify
      ];
    };
    var properties = function() {
      return [
        new Property({
          name: "hive",
          getter: "bzz_hive"
        }),
        new Property({
          name: "info",
          getter: "bzz_info"
        })
      ];
    };
    module.exports = Swarm;
  }
});

// node_modules/web3/lib/web3/settings.js
var require_settings = __commonJS({
  "node_modules/web3/lib/web3/settings.js"(exports, module) {
    var Settings = function() {
      this.defaultBlock = "latest";
      this.defaultAccount = void 0;
    };
    module.exports = Settings;
  }
});

// node_modules/web3/lib/version.json
var require_version = __commonJS({
  "node_modules/web3/lib/version.json"(exports, module) {
    module.exports = {
      version: "0.20.7"
    };
  }
});

// node_modules/web3/lib/web3/extend.js
var require_extend = __commonJS({
  "node_modules/web3/lib/web3/extend.js"(exports, module) {
    var formatters = require_formatters();
    var utils = require_utils();
    var Method = require_method();
    var Property = require_property();
    var extend = function(web3) {
      var ex = function(extension) {
        var extendedObject;
        if (extension.property) {
          if (!web3[extension.property]) {
            web3[extension.property] = {};
          }
          extendedObject = web3[extension.property];
        } else {
          extendedObject = web3;
        }
        if (extension.methods) {
          extension.methods.forEach(function(method) {
            method.attachToObject(extendedObject);
            method.setRequestManager(web3._requestManager);
          });
        }
        if (extension.properties) {
          extension.properties.forEach(function(property) {
            property.attachToObject(extendedObject);
            property.setRequestManager(web3._requestManager);
          });
        }
      };
      ex.formatters = formatters;
      ex.utils = utils;
      ex.Method = Method;
      ex.Property = Property;
      return ex;
    };
    module.exports = extend;
  }
});

// node_modules/web3/lib/web3/batch.js
var require_batch = __commonJS({
  "node_modules/web3/lib/web3/batch.js"(exports, module) {
    var Jsonrpc = require_jsonrpc();
    var errors = require_errors();
    var Batch = function(web3) {
      this.requestManager = web3._requestManager;
      this.requests = [];
    };
    Batch.prototype.add = function(request) {
      this.requests.push(request);
    };
    Batch.prototype.execute = function() {
      var requests = this.requests;
      this.requestManager.sendBatch(requests, function(err, results) {
        results = results || [];
        requests.map(function(request, index) {
          return results[index] || {};
        }).forEach(function(result, index) {
          if (requests[index].callback) {
            if (!Jsonrpc.isValidResponse(result)) {
              return requests[index].callback(errors.InvalidResponse(result));
            }
            requests[index].callback(null, requests[index].format ? requests[index].format(result.result) : result.result);
          }
        });
      });
    };
    module.exports = Batch;
  }
});

// node_modules/web3/lib/utils/browser-xhr.js
var require_browser_xhr = __commonJS({
  "node_modules/web3/lib/utils/browser-xhr.js"(exports) {
    "use strict";
    if (typeof XMLHttpRequest === "undefined") {
      exports.XMLHttpRequest = {};
    } else {
      exports.XMLHttpRequest = XMLHttpRequest;
    }
  }
});

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "http" has been externalized for browser compatibility. Cannot access "http.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "https" has been externalized for browser compatibility. Cannot access "https.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/xhr2-cookies/dist/progress-event.js
var require_progress_event = __commonJS({
  "node_modules/xhr2-cookies/dist/progress-event.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ProgressEvent = (
      /** @class */
      function() {
        function ProgressEvent2(type) {
          this.type = type;
          this.bubbles = false;
          this.cancelable = false;
          this.loaded = 0;
          this.lengthComputable = false;
          this.total = 0;
        }
        return ProgressEvent2;
      }()
    );
    exports.ProgressEvent = ProgressEvent;
  }
});

// node_modules/xhr2-cookies/dist/errors.js
var require_errors2 = __commonJS({
  "node_modules/xhr2-cookies/dist/errors.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var SecurityError = (
      /** @class */
      function(_super) {
        __extends(SecurityError2, _super);
        function SecurityError2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return SecurityError2;
      }(Error)
    );
    exports.SecurityError = SecurityError;
    var InvalidStateError = (
      /** @class */
      function(_super) {
        __extends(InvalidStateError2, _super);
        function InvalidStateError2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return InvalidStateError2;
      }(Error)
    );
    exports.InvalidStateError = InvalidStateError;
    var NetworkError = (
      /** @class */
      function(_super) {
        __extends(NetworkError2, _super);
        function NetworkError2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return NetworkError2;
      }(Error)
    );
    exports.NetworkError = NetworkError;
    var SyntaxError = (
      /** @class */
      function(_super) {
        __extends(SyntaxError2, _super);
        function SyntaxError2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return SyntaxError2;
      }(Error)
    );
    exports.SyntaxError = SyntaxError;
  }
});

// node_modules/xhr2-cookies/dist/xml-http-request-event-target.js
var require_xml_http_request_event_target = __commonJS({
  "node_modules/xhr2-cookies/dist/xml-http-request-event-target.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var XMLHttpRequestEventTarget = (
      /** @class */
      function() {
        function XMLHttpRequestEventTarget2() {
          this.listeners = {};
        }
        XMLHttpRequestEventTarget2.prototype.addEventListener = function(eventType, listener) {
          eventType = eventType.toLowerCase();
          this.listeners[eventType] = this.listeners[eventType] || [];
          this.listeners[eventType].push(listener.handleEvent || listener);
        };
        XMLHttpRequestEventTarget2.prototype.removeEventListener = function(eventType, listener) {
          eventType = eventType.toLowerCase();
          if (!this.listeners[eventType]) {
            return;
          }
          var index = this.listeners[eventType].indexOf(listener.handleEvent || listener);
          if (index < 0) {
            return;
          }
          this.listeners[eventType].splice(index, 1);
        };
        XMLHttpRequestEventTarget2.prototype.dispatchEvent = function(event) {
          var eventType = event.type.toLowerCase();
          event.target = this;
          if (this.listeners[eventType]) {
            for (var _i = 0, _a = this.listeners[eventType]; _i < _a.length; _i++) {
              var listener_1 = _a[_i];
              listener_1.call(this, event);
            }
          }
          var listener = this["on" + eventType];
          if (listener) {
            listener.call(this, event);
          }
          return true;
        };
        return XMLHttpRequestEventTarget2;
      }()
    );
    exports.XMLHttpRequestEventTarget = XMLHttpRequestEventTarget;
  }
});

// node_modules/xhr2-cookies/dist/xml-http-request-upload.js
var require_xml_http_request_upload = __commonJS({
  "node_modules/xhr2-cookies/dist/xml-http-request-upload.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var xml_http_request_event_target_1 = require_xml_http_request_event_target();
    var XMLHttpRequestUpload = (
      /** @class */
      function(_super) {
        __extends(XMLHttpRequestUpload2, _super);
        function XMLHttpRequestUpload2() {
          var _this = _super.call(this) || this;
          _this._contentType = null;
          _this._body = null;
          _this._reset();
          return _this;
        }
        XMLHttpRequestUpload2.prototype._reset = function() {
          this._contentType = null;
          this._body = null;
        };
        XMLHttpRequestUpload2.prototype._setData = function(data) {
          if (data == null) {
            return;
          }
          if (typeof data === "string") {
            if (data.length !== 0) {
              this._contentType = "text/plain;charset=UTF-8";
            }
            this._body = new Buffer(data, "utf-8");
          } else if (Buffer.isBuffer(data)) {
            this._body = data;
          } else if (data instanceof ArrayBuffer) {
            var body = new Buffer(data.byteLength);
            var view = new Uint8Array(data);
            for (var i = 0; i < data.byteLength; i++) {
              body[i] = view[i];
            }
            this._body = body;
          } else if (data.buffer && data.buffer instanceof ArrayBuffer) {
            var body = new Buffer(data.byteLength);
            var offset = data.byteOffset;
            var view = new Uint8Array(data.buffer);
            for (var i = 0; i < data.byteLength; i++) {
              body[i] = view[i + offset];
            }
            this._body = body;
          } else {
            throw new Error("Unsupported send() data " + data);
          }
        };
        XMLHttpRequestUpload2.prototype._finalizeHeaders = function(headers, loweredHeaders) {
          if (this._contentType && !loweredHeaders["content-type"]) {
            headers["Content-Type"] = this._contentType;
          }
          if (this._body) {
            headers["Content-Length"] = this._body.length.toString();
          }
        };
        XMLHttpRequestUpload2.prototype._startUpload = function(request) {
          if (this._body) {
            request.write(this._body);
          }
          request.end();
        };
        return XMLHttpRequestUpload2;
      }(xml_http_request_event_target_1.XMLHttpRequestEventTarget)
    );
    exports.XMLHttpRequestUpload = XMLHttpRequestUpload;
  }
});

// node_modules/cookiejar/cookiejar.js
var require_cookiejar = __commonJS({
  "node_modules/cookiejar/cookiejar.js"(exports) {
    (function() {
      "use strict";
      function CookieAccessInfo(domain, path, secure, script) {
        if (this instanceof CookieAccessInfo) {
          this.domain = domain || void 0;
          this.path = path || "/";
          this.secure = !!secure;
          this.script = !!script;
          return this;
        }
        return new CookieAccessInfo(domain, path, secure, script);
      }
      CookieAccessInfo.All = Object.freeze(/* @__PURE__ */ Object.create(null));
      exports.CookieAccessInfo = CookieAccessInfo;
      function Cookie(cookiestr, request_domain, request_path) {
        if (cookiestr instanceof Cookie) {
          return cookiestr;
        }
        if (this instanceof Cookie) {
          this.name = null;
          this.value = null;
          this.expiration_date = Infinity;
          this.path = String(request_path || "/");
          this.explicit_path = false;
          this.domain = request_domain || null;
          this.explicit_domain = false;
          this.secure = false;
          this.noscript = false;
          if (cookiestr) {
            this.parse(cookiestr, request_domain, request_path);
          }
          return this;
        }
        return new Cookie(cookiestr, request_domain, request_path);
      }
      exports.Cookie = Cookie;
      Cookie.prototype.toString = function toString() {
        var str = [this.name + "=" + this.value];
        if (this.expiration_date !== Infinity) {
          str.push("expires=" + new Date(this.expiration_date).toGMTString());
        }
        if (this.domain) {
          str.push("domain=" + this.domain);
        }
        if (this.path) {
          str.push("path=" + this.path);
        }
        if (this.secure) {
          str.push("secure");
        }
        if (this.noscript) {
          str.push("httponly");
        }
        return str.join("; ");
      };
      Cookie.prototype.toValueString = function toValueString() {
        return this.name + "=" + this.value;
      };
      var cookie_str_splitter = /[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g;
      Cookie.prototype.parse = function parse(str, request_domain, request_path) {
        if (this instanceof Cookie) {
          if (str.length > 32768) {
            console.warn("Cookie too long for parsing (>32768 characters)");
            return;
          }
          var parts = str.split(";").filter(function(value2) {
            return !!value2;
          });
          var i;
          var pair = parts[0].match(/([^=]+)=([\s\S]*)/);
          if (!pair) {
            console.warn("Invalid cookie header encountered. Header: '" + str + "'");
            return;
          }
          var key = pair[1];
          var value = pair[2];
          if (typeof key !== "string" || key.length === 0 || typeof value !== "string") {
            console.warn("Unable to extract values from cookie header. Cookie: '" + str + "'");
            return;
          }
          this.name = key;
          this.value = value;
          for (i = 1; i < parts.length; i += 1) {
            pair = parts[i].match(/([^=]+)(?:=([\s\S]*))?/);
            key = pair[1].trim().toLowerCase();
            value = pair[2];
            switch (key) {
              case "httponly":
                this.noscript = true;
                break;
              case "expires":
                this.expiration_date = value ? Number(Date.parse(value)) : Infinity;
                break;
              case "path":
                this.path = value ? value.trim() : "";
                this.explicit_path = true;
                break;
              case "domain":
                this.domain = value ? value.trim() : "";
                this.explicit_domain = !!this.domain;
                break;
              case "secure":
                this.secure = true;
                break;
            }
          }
          if (!this.explicit_path) {
            this.path = request_path || "/";
          }
          if (!this.explicit_domain) {
            this.domain = request_domain;
          }
          return this;
        }
        return new Cookie().parse(str, request_domain, request_path);
      };
      Cookie.prototype.matches = function matches(access_info) {
        if (access_info === CookieAccessInfo.All) {
          return true;
        }
        if (this.noscript && access_info.script || this.secure && !access_info.secure || !this.collidesWith(access_info)) {
          return false;
        }
        return true;
      };
      Cookie.prototype.collidesWith = function collidesWith(access_info) {
        if (this.path && !access_info.path || this.domain && !access_info.domain) {
          return false;
        }
        if (this.path && access_info.path.indexOf(this.path) !== 0) {
          return false;
        }
        if (this.explicit_path && access_info.path.indexOf(this.path) !== 0) {
          return false;
        }
        var access_domain = access_info.domain && access_info.domain.replace(/^[\.]/, "");
        var cookie_domain = this.domain && this.domain.replace(/^[\.]/, "");
        if (cookie_domain === access_domain) {
          return true;
        }
        if (cookie_domain) {
          if (!this.explicit_domain) {
            return false;
          }
          var wildcard = access_domain.indexOf(cookie_domain);
          if (wildcard === -1 || wildcard !== access_domain.length - cookie_domain.length) {
            return false;
          }
          return true;
        }
        return true;
      };
      function CookieJar() {
        var cookies, cookies_list, collidable_cookie;
        if (this instanceof CookieJar) {
          cookies = /* @__PURE__ */ Object.create(null);
          this.setCookie = function setCookie(cookie, request_domain, request_path) {
            var remove, i;
            cookie = new Cookie(cookie, request_domain, request_path);
            remove = cookie.expiration_date <= Date.now();
            if (cookies[cookie.name] !== void 0) {
              cookies_list = cookies[cookie.name];
              for (i = 0; i < cookies_list.length; i += 1) {
                collidable_cookie = cookies_list[i];
                if (collidable_cookie.collidesWith(cookie)) {
                  if (remove) {
                    cookies_list.splice(i, 1);
                    if (cookies_list.length === 0) {
                      delete cookies[cookie.name];
                    }
                    return false;
                  }
                  cookies_list[i] = cookie;
                  return cookie;
                }
              }
              if (remove) {
                return false;
              }
              cookies_list.push(cookie);
              return cookie;
            }
            if (remove) {
              return false;
            }
            cookies[cookie.name] = [cookie];
            return cookies[cookie.name];
          };
          this.getCookie = function getCookie(cookie_name, access_info) {
            var cookie, i;
            cookies_list = cookies[cookie_name];
            if (!cookies_list) {
              return;
            }
            for (i = 0; i < cookies_list.length; i += 1) {
              cookie = cookies_list[i];
              if (cookie.expiration_date <= Date.now()) {
                if (cookies_list.length === 0) {
                  delete cookies[cookie.name];
                }
                continue;
              }
              if (cookie.matches(access_info)) {
                return cookie;
              }
            }
          };
          this.getCookies = function getCookies(access_info) {
            var matches = [], cookie_name, cookie;
            for (cookie_name in cookies) {
              cookie = this.getCookie(cookie_name, access_info);
              if (cookie) {
                matches.push(cookie);
              }
            }
            matches.toString = function toString() {
              return matches.join(":");
            };
            matches.toValueString = function toValueString() {
              return matches.map(function(c) {
                return c.toValueString();
              }).join("; ");
            };
            return matches;
          };
          return this;
        }
        return new CookieJar();
      }
      exports.CookieJar = CookieJar;
      CookieJar.prototype.setCookies = function setCookies(cookies, request_domain, request_path) {
        cookies = Array.isArray(cookies) ? cookies : cookies.split(cookie_str_splitter);
        var successful = [], i, cookie;
        cookies = cookies.map(function(item) {
          return new Cookie(item, request_domain, request_path);
        });
        for (i = 0; i < cookies.length; i += 1) {
          cookie = cookies[i];
          if (this.setCookie(cookie, request_domain, request_path)) {
            successful.push(cookie);
          }
        }
        return successful;
      };
    })();
  }
});

// node_modules/xhr2-cookies/dist/xml-http-request.js
var require_xml_http_request = __commonJS({
  "node_modules/xhr2-cookies/dist/xml-http-request.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var http = require_http();
    var https = require_https();
    var os = require_os();
    var url = require_url();
    var progress_event_1 = require_progress_event();
    var errors_1 = require_errors2();
    var xml_http_request_event_target_1 = require_xml_http_request_event_target();
    var xml_http_request_upload_1 = require_xml_http_request_upload();
    var Cookie = require_cookiejar();
    var XMLHttpRequest2 = (
      /** @class */
      function(_super) {
        __extends(XMLHttpRequest3, _super);
        function XMLHttpRequest3(options) {
          if (options === void 0) {
            options = {};
          }
          var _this = _super.call(this) || this;
          _this.UNSENT = XMLHttpRequest3.UNSENT;
          _this.OPENED = XMLHttpRequest3.OPENED;
          _this.HEADERS_RECEIVED = XMLHttpRequest3.HEADERS_RECEIVED;
          _this.LOADING = XMLHttpRequest3.LOADING;
          _this.DONE = XMLHttpRequest3.DONE;
          _this.onreadystatechange = null;
          _this.readyState = XMLHttpRequest3.UNSENT;
          _this.response = null;
          _this.responseText = "";
          _this.responseType = "";
          _this.status = 0;
          _this.statusText = "";
          _this.timeout = 0;
          _this.upload = new xml_http_request_upload_1.XMLHttpRequestUpload();
          _this.responseUrl = "";
          _this.withCredentials = false;
          _this._method = null;
          _this._url = null;
          _this._sync = false;
          _this._headers = {};
          _this._loweredHeaders = {};
          _this._mimeOverride = null;
          _this._request = null;
          _this._response = null;
          _this._responseParts = null;
          _this._responseHeaders = null;
          _this._aborting = null;
          _this._error = null;
          _this._loadedBytes = 0;
          _this._totalBytes = 0;
          _this._lengthComputable = false;
          _this._restrictedMethods = { CONNECT: true, TRACE: true, TRACK: true };
          _this._restrictedHeaders = {
            "accept-charset": true,
            "accept-encoding": true,
            "access-control-request-headers": true,
            "access-control-request-method": true,
            connection: true,
            "content-length": true,
            cookie: true,
            cookie2: true,
            date: true,
            dnt: true,
            expect: true,
            host: true,
            "keep-alive": true,
            origin: true,
            referer: true,
            te: true,
            trailer: true,
            "transfer-encoding": true,
            upgrade: true,
            "user-agent": true,
            via: true
          };
          _this._privateHeaders = { "set-cookie": true, "set-cookie2": true };
          _this._userAgent = "Mozilla/5.0 (" + os.type() + " " + os.arch() + ") node.js/" + process.versions.node + " v8/" + process.versions.v8;
          _this._anonymous = options.anon || false;
          return _this;
        }
        XMLHttpRequest3.prototype.open = function(method, url2, async, user, password) {
          if (async === void 0) {
            async = true;
          }
          method = method.toUpperCase();
          if (this._restrictedMethods[method]) {
            throw new XMLHttpRequest3.SecurityError("HTTP method " + method + " is not allowed in XHR");
          }
          ;
          var xhrUrl = this._parseUrl(url2, user, password);
          if (this.readyState === XMLHttpRequest3.HEADERS_RECEIVED || this.readyState === XMLHttpRequest3.LOADING) {
          }
          this._method = method;
          this._url = xhrUrl;
          this._sync = !async;
          this._headers = {};
          this._loweredHeaders = {};
          this._mimeOverride = null;
          this._setReadyState(XMLHttpRequest3.OPENED);
          this._request = null;
          this._response = null;
          this.status = 0;
          this.statusText = "";
          this._responseParts = [];
          this._responseHeaders = null;
          this._loadedBytes = 0;
          this._totalBytes = 0;
          this._lengthComputable = false;
        };
        XMLHttpRequest3.prototype.setRequestHeader = function(name, value) {
          if (this.readyState !== XMLHttpRequest3.OPENED) {
            throw new XMLHttpRequest3.InvalidStateError("XHR readyState must be OPENED");
          }
          var loweredName = name.toLowerCase();
          if (this._restrictedHeaders[loweredName] || /^sec-/.test(loweredName) || /^proxy-/.test(loweredName)) {
            console.warn('Refused to set unsafe header "' + name + '"');
            return;
          }
          value = value.toString();
          if (this._loweredHeaders[loweredName] != null) {
            name = this._loweredHeaders[loweredName];
            this._headers[name] = this._headers[name] + ", " + value;
          } else {
            this._loweredHeaders[loweredName] = name;
            this._headers[name] = value;
          }
        };
        XMLHttpRequest3.prototype.send = function(data) {
          if (this.readyState !== XMLHttpRequest3.OPENED) {
            throw new XMLHttpRequest3.InvalidStateError("XHR readyState must be OPENED");
          }
          if (this._request) {
            throw new XMLHttpRequest3.InvalidStateError("send() already called");
          }
          switch (this._url.protocol) {
            case "file:":
              return this._sendFile(data);
            case "http:":
            case "https:":
              return this._sendHttp(data);
            default:
              throw new XMLHttpRequest3.NetworkError("Unsupported protocol " + this._url.protocol);
          }
        };
        XMLHttpRequest3.prototype.abort = function() {
          if (this._request == null) {
            return;
          }
          this._request.abort();
          this._setError();
          this._dispatchProgress("abort");
          this._dispatchProgress("loadend");
        };
        XMLHttpRequest3.prototype.getResponseHeader = function(name) {
          if (this._responseHeaders == null || name == null) {
            return null;
          }
          var loweredName = name.toLowerCase();
          return this._responseHeaders.hasOwnProperty(loweredName) ? this._responseHeaders[name.toLowerCase()] : null;
        };
        XMLHttpRequest3.prototype.getAllResponseHeaders = function() {
          var _this = this;
          if (this._responseHeaders == null) {
            return "";
          }
          return Object.keys(this._responseHeaders).map(function(key) {
            return key + ": " + _this._responseHeaders[key];
          }).join("\r\n");
        };
        XMLHttpRequest3.prototype.overrideMimeType = function(mimeType) {
          if (this.readyState === XMLHttpRequest3.LOADING || this.readyState === XMLHttpRequest3.DONE) {
            throw new XMLHttpRequest3.InvalidStateError("overrideMimeType() not allowed in LOADING or DONE");
          }
          this._mimeOverride = mimeType.toLowerCase();
        };
        XMLHttpRequest3.prototype.nodejsSet = function(options) {
          this.nodejsHttpAgent = options.httpAgent || this.nodejsHttpAgent;
          this.nodejsHttpsAgent = options.httpsAgent || this.nodejsHttpsAgent;
          if (options.hasOwnProperty("baseUrl")) {
            if (options.baseUrl != null) {
              var parsedUrl = url.parse(options.baseUrl, false, true);
              if (!parsedUrl.protocol) {
                throw new XMLHttpRequest3.SyntaxError("baseUrl must be an absolute URL");
              }
            }
            this.nodejsBaseUrl = options.baseUrl;
          }
        };
        XMLHttpRequest3.nodejsSet = function(options) {
          XMLHttpRequest3.prototype.nodejsSet(options);
        };
        XMLHttpRequest3.prototype._setReadyState = function(readyState) {
          this.readyState = readyState;
          this.dispatchEvent(new progress_event_1.ProgressEvent("readystatechange"));
        };
        XMLHttpRequest3.prototype._sendFile = function(data) {
          throw new Error("Protocol file: not implemented");
        };
        XMLHttpRequest3.prototype._sendHttp = function(data) {
          if (this._sync) {
            throw new Error("Synchronous XHR processing not implemented");
          }
          if (data && (this._method === "GET" || this._method === "HEAD")) {
            console.warn("Discarding entity body for " + this._method + " requests");
            data = null;
          } else {
            data = data || "";
          }
          this.upload._setData(data);
          this._finalizeHeaders();
          this._sendHxxpRequest();
        };
        XMLHttpRequest3.prototype._sendHxxpRequest = function() {
          var _this = this;
          if (this.withCredentials) {
            var cookie = XMLHttpRequest3.cookieJar.getCookies(Cookie.CookieAccessInfo(this._url.hostname, this._url.pathname, this._url.protocol === "https:")).toValueString();
            this._headers.cookie = this._headers.cookie2 = cookie;
          }
          var _a = this._url.protocol === "http:" ? [http, this.nodejsHttpAgent] : [https, this.nodejsHttpsAgent], hxxp = _a[0], agent = _a[1];
          var requestMethod = hxxp.request.bind(hxxp);
          var request = requestMethod({
            hostname: this._url.hostname,
            port: +this._url.port,
            path: this._url.path,
            auth: this._url.auth,
            method: this._method,
            headers: this._headers,
            agent
          });
          this._request = request;
          if (this.timeout) {
            request.setTimeout(this.timeout, function() {
              return _this._onHttpTimeout(request);
            });
          }
          request.on("response", function(response) {
            return _this._onHttpResponse(request, response);
          });
          request.on("error", function(error) {
            return _this._onHttpRequestError(request, error);
          });
          this.upload._startUpload(request);
          if (this._request === request) {
            this._dispatchProgress("loadstart");
          }
        };
        XMLHttpRequest3.prototype._finalizeHeaders = function() {
          this._headers = __assign({}, this._headers, { Connection: "keep-alive", Host: this._url.host, "User-Agent": this._userAgent }, this._anonymous ? { Referer: "about:blank" } : {});
          this.upload._finalizeHeaders(this._headers, this._loweredHeaders);
        };
        XMLHttpRequest3.prototype._onHttpResponse = function(request, response) {
          var _this = this;
          if (this._request !== request) {
            return;
          }
          if (this.withCredentials && (response.headers["set-cookie"] || response.headers["set-cookie2"])) {
            XMLHttpRequest3.cookieJar.setCookies(response.headers["set-cookie"] || response.headers["set-cookie2"]);
          }
          if ([301, 302, 303, 307, 308].indexOf(response.statusCode) >= 0) {
            this._url = this._parseUrl(response.headers.location);
            this._method = "GET";
            if (this._loweredHeaders["content-type"]) {
              delete this._headers[this._loweredHeaders["content-type"]];
              delete this._loweredHeaders["content-type"];
            }
            if (this._headers["Content-Type"] != null) {
              delete this._headers["Content-Type"];
            }
            delete this._headers["Content-Length"];
            this.upload._reset();
            this._finalizeHeaders();
            this._sendHxxpRequest();
            return;
          }
          this._response = response;
          this._response.on("data", function(data) {
            return _this._onHttpResponseData(response, data);
          });
          this._response.on("end", function() {
            return _this._onHttpResponseEnd(response);
          });
          this._response.on("close", function() {
            return _this._onHttpResponseClose(response);
          });
          this.responseUrl = this._url.href.split("#")[0];
          this.status = response.statusCode;
          this.statusText = http.STATUS_CODES[this.status];
          this._parseResponseHeaders(response);
          var lengthString = this._responseHeaders["content-length"] || "";
          this._totalBytes = +lengthString;
          this._lengthComputable = !!lengthString;
          this._setReadyState(XMLHttpRequest3.HEADERS_RECEIVED);
        };
        XMLHttpRequest3.prototype._onHttpResponseData = function(response, data) {
          if (this._response !== response) {
            return;
          }
          this._responseParts.push(new Buffer(data));
          this._loadedBytes += data.length;
          if (this.readyState !== XMLHttpRequest3.LOADING) {
            this._setReadyState(XMLHttpRequest3.LOADING);
          }
          this._dispatchProgress("progress");
        };
        XMLHttpRequest3.prototype._onHttpResponseEnd = function(response) {
          if (this._response !== response) {
            return;
          }
          this._parseResponse();
          this._request = null;
          this._response = null;
          this._setReadyState(XMLHttpRequest3.DONE);
          this._dispatchProgress("load");
          this._dispatchProgress("loadend");
        };
        XMLHttpRequest3.prototype._onHttpResponseClose = function(response) {
          if (this._response !== response) {
            return;
          }
          var request = this._request;
          this._setError();
          request.abort();
          this._setReadyState(XMLHttpRequest3.DONE);
          this._dispatchProgress("error");
          this._dispatchProgress("loadend");
        };
        XMLHttpRequest3.prototype._onHttpTimeout = function(request) {
          if (this._request !== request) {
            return;
          }
          this._setError();
          request.abort();
          this._setReadyState(XMLHttpRequest3.DONE);
          this._dispatchProgress("timeout");
          this._dispatchProgress("loadend");
        };
        XMLHttpRequest3.prototype._onHttpRequestError = function(request, error) {
          if (this._request !== request) {
            return;
          }
          this._setError();
          request.abort();
          this._setReadyState(XMLHttpRequest3.DONE);
          this._dispatchProgress("error");
          this._dispatchProgress("loadend");
        };
        XMLHttpRequest3.prototype._dispatchProgress = function(eventType) {
          var event = new XMLHttpRequest3.ProgressEvent(eventType);
          event.lengthComputable = this._lengthComputable;
          event.loaded = this._loadedBytes;
          event.total = this._totalBytes;
          this.dispatchEvent(event);
        };
        XMLHttpRequest3.prototype._setError = function() {
          this._request = null;
          this._response = null;
          this._responseHeaders = null;
          this._responseParts = null;
        };
        XMLHttpRequest3.prototype._parseUrl = function(urlString, user, password) {
          var absoluteUrl = this.nodejsBaseUrl == null ? urlString : url.resolve(this.nodejsBaseUrl, urlString);
          var xhrUrl = url.parse(absoluteUrl, false, true);
          xhrUrl.hash = null;
          var _a = (xhrUrl.auth || "").split(":"), xhrUser = _a[0], xhrPassword = _a[1];
          if (xhrUser || xhrPassword || user || password) {
            xhrUrl.auth = (user || xhrUser || "") + ":" + (password || xhrPassword || "");
          }
          return xhrUrl;
        };
        XMLHttpRequest3.prototype._parseResponseHeaders = function(response) {
          this._responseHeaders = {};
          for (var name_1 in response.headers) {
            var loweredName = name_1.toLowerCase();
            if (this._privateHeaders[loweredName]) {
              continue;
            }
            this._responseHeaders[loweredName] = response.headers[name_1];
          }
          if (this._mimeOverride != null) {
            this._responseHeaders["content-type"] = this._mimeOverride;
          }
        };
        XMLHttpRequest3.prototype._parseResponse = function() {
          var buffer = Buffer.concat(this._responseParts);
          this._responseParts = null;
          switch (this.responseType) {
            case "json":
              this.responseText = null;
              try {
                this.response = JSON.parse(buffer.toString("utf-8"));
              } catch (_a) {
                this.response = null;
              }
              return;
            case "buffer":
              this.responseText = null;
              this.response = buffer;
              return;
            case "arraybuffer":
              this.responseText = null;
              var arrayBuffer = new ArrayBuffer(buffer.length);
              var view = new Uint8Array(arrayBuffer);
              for (var i = 0; i < buffer.length; i++) {
                view[i] = buffer[i];
              }
              this.response = arrayBuffer;
              return;
            case "text":
            default:
              try {
                this.responseText = buffer.toString(this._parseResponseEncoding());
              } catch (_b) {
                this.responseText = buffer.toString("binary");
              }
              this.response = this.responseText;
          }
        };
        XMLHttpRequest3.prototype._parseResponseEncoding = function() {
          return /;\s*charset=(.*)$/.exec(this._responseHeaders["content-type"] || "")[1] || "utf-8";
        };
        XMLHttpRequest3.ProgressEvent = progress_event_1.ProgressEvent;
        XMLHttpRequest3.InvalidStateError = errors_1.InvalidStateError;
        XMLHttpRequest3.NetworkError = errors_1.NetworkError;
        XMLHttpRequest3.SecurityError = errors_1.SecurityError;
        XMLHttpRequest3.SyntaxError = errors_1.SyntaxError;
        XMLHttpRequest3.XMLHttpRequestUpload = xml_http_request_upload_1.XMLHttpRequestUpload;
        XMLHttpRequest3.UNSENT = 0;
        XMLHttpRequest3.OPENED = 1;
        XMLHttpRequest3.HEADERS_RECEIVED = 2;
        XMLHttpRequest3.LOADING = 3;
        XMLHttpRequest3.DONE = 4;
        XMLHttpRequest3.cookieJar = Cookie.CookieJar();
        return XMLHttpRequest3;
      }(xml_http_request_event_target_1.XMLHttpRequestEventTarget)
    );
    exports.XMLHttpRequest = XMLHttpRequest2;
    XMLHttpRequest2.prototype.nodejsHttpAgent = http.globalAgent;
    XMLHttpRequest2.prototype.nodejsHttpsAgent = https.globalAgent;
    XMLHttpRequest2.prototype.nodejsBaseUrl = null;
  }
});

// node_modules/xhr2-cookies/dist/index.js
var require_dist = __commonJS({
  "node_modules/xhr2-cookies/dist/index.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(require_xml_http_request());
    var xml_http_request_event_target_1 = require_xml_http_request_event_target();
    exports.XMLHttpRequestEventTarget = xml_http_request_event_target_1.XMLHttpRequestEventTarget;
  }
});

// node_modules/web3/lib/web3/httpprovider.js
var require_httpprovider = __commonJS({
  "node_modules/web3/lib/web3/httpprovider.js"(exports, module) {
    var errors = require_errors();
    if (typeof window !== "undefined" && window.XMLHttpRequest) {
      XMLHttpRequest = window.XMLHttpRequest;
    } else {
      XMLHttpRequest = require_browser_xhr().XMLHttpRequest;
    }
    var XHR2 = require_dist().XMLHttpRequest;
    var HttpProvider = function(host, timeout, user, password, headers) {
      this.host = host || "http://localhost:8545";
      this.timeout = timeout || 0;
      this.user = user;
      this.password = password;
      this.headers = headers;
    };
    HttpProvider.prototype.prepareRequest = function(async) {
      var request;
      if (async) {
        request = new XHR2();
        request.timeout = this.timeout;
      } else {
        request = new XMLHttpRequest();
      }
      request.withCredentials = true;
      request.open("POST", this.host, async);
      if (this.user && this.password) {
        var auth = "Basic " + new Buffer(this.user + ":" + this.password).toString("base64");
        request.setRequestHeader("Authorization", auth);
      }
      request.setRequestHeader("Content-Type", "application/json");
      if (this.headers) {
        this.headers.forEach(function(header) {
          request.setRequestHeader(header.name, header.value);
        });
      }
      return request;
    };
    HttpProvider.prototype.send = function(payload) {
      var request = this.prepareRequest(false);
      try {
        request.send(JSON.stringify(payload));
      } catch (error) {
        throw errors.InvalidConnection(this.host);
      }
      var result = request.responseText;
      try {
        result = JSON.parse(result);
      } catch (e) {
        throw errors.InvalidResponse(request.responseText);
      }
      return result;
    };
    HttpProvider.prototype.sendAsync = function(payload, callback) {
      var request = this.prepareRequest(true);
      request.onreadystatechange = function() {
        if (request.readyState === 4 && request.timeout !== 1) {
          var result = request.responseText;
          var error = null;
          try {
            result = JSON.parse(result);
          } catch (e) {
            error = errors.InvalidResponse(request.responseText);
          }
          callback(error, result);
        }
      };
      request.ontimeout = function() {
        callback(errors.ConnectionTimeout(this.timeout));
      };
      try {
        request.send(JSON.stringify(payload));
      } catch (error) {
        callback(errors.InvalidConnection(this.host));
      }
    };
    HttpProvider.prototype.isConnected = function() {
      try {
        this.send({
          id: 9999999999,
          jsonrpc: "2.0",
          method: "net_listening",
          params: []
        });
        return true;
      } catch (e) {
        return false;
      }
    };
    module.exports = HttpProvider;
  }
});

// node_modules/web3/lib/web3/ipcprovider.js
var require_ipcprovider = __commonJS({
  "node_modules/web3/lib/web3/ipcprovider.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var errors = require_errors();
    var IpcProvider = function(path, net) {
      var _this = this;
      this.responseCallbacks = {};
      this.path = path;
      this.connection = net.connect({ path: this.path });
      this.connection.on("error", function(e) {
        console.error("IPC Connection Error", e);
        _this._timeout();
      });
      this.connection.on("end", function() {
        _this._timeout();
      });
      this.connection.on("data", function(data) {
        _this._parseResponse(data.toString()).forEach(function(result) {
          var id = null;
          if (utils.isArray(result)) {
            result.forEach(function(load) {
              if (_this.responseCallbacks[load.id])
                id = load.id;
            });
          } else {
            id = result.id;
          }
          if (_this.responseCallbacks[id]) {
            _this.responseCallbacks[id](null, result);
            delete _this.responseCallbacks[id];
          }
        });
      });
    };
    IpcProvider.prototype._parseResponse = function(data) {
      var _this = this, returnValues = [];
      var dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
      dechunkedData.forEach(function(data2) {
        if (_this.lastChunk)
          data2 = _this.lastChunk + data2;
        var result = null;
        try {
          result = JSON.parse(data2);
        } catch (e) {
          _this.lastChunk = data2;
          clearTimeout(_this.lastChunkTimeout);
          _this.lastChunkTimeout = setTimeout(function() {
            _this._timeout();
            throw errors.InvalidResponse(data2);
          }, 1e3 * 15);
          return;
        }
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;
        if (result)
          returnValues.push(result);
      });
      return returnValues;
    };
    IpcProvider.prototype._addResponseCallback = function(payload, callback) {
      var id = payload.id || payload[0].id;
      var method = payload.method || payload[0].method;
      this.responseCallbacks[id] = callback;
      this.responseCallbacks[id].method = method;
    };
    IpcProvider.prototype._timeout = function() {
      for (var key in this.responseCallbacks) {
        if (this.responseCallbacks.hasOwnProperty(key)) {
          this.responseCallbacks[key](errors.InvalidConnection("on IPC"));
          delete this.responseCallbacks[key];
        }
      }
    };
    IpcProvider.prototype.isConnected = function() {
      var _this = this;
      if (!_this.connection.writable)
        _this.connection.connect({ path: _this.path });
      return !!this.connection.writable;
    };
    IpcProvider.prototype.send = function(payload) {
      if (this.connection.writeSync) {
        var result;
        if (!this.connection.writable)
          this.connection.connect({ path: this.path });
        var data = this.connection.writeSync(JSON.stringify(payload));
        try {
          result = JSON.parse(data);
        } catch (e) {
          throw errors.InvalidResponse(data);
        }
        return result;
      } else {
        throw new Error('You tried to send "' + payload.method + '" synchronously. Synchronous requests are not supported by the IPC provider.');
      }
    };
    IpcProvider.prototype.sendAsync = function(payload, callback) {
      if (!this.connection.writable)
        this.connection.connect({ path: this.path });
      this.connection.write(JSON.stringify(payload));
      this._addResponseCallback(payload, callback);
    };
    module.exports = IpcProvider;
  }
});

// node_modules/web3/lib/web3.js
var require_web3 = __commonJS({
  "node_modules/web3/lib/web3.js"(exports, module) {
    var RequestManager = require_requestmanager();
    var Iban = require_iban();
    var Eth = require_eth();
    var DB = require_db();
    var Shh = require_shh();
    var Net = require_net();
    var Personal = require_personal();
    var Swarm = require_swarm();
    var Settings = require_settings();
    var version = require_version();
    var utils = require_utils();
    var sha3 = require_sha32();
    var extend = require_extend();
    var Batch = require_batch();
    var Property = require_property();
    var HttpProvider = require_httpprovider();
    var IpcProvider = require_ipcprovider();
    var BigNumber = require_bignumber();
    function Web3(provider) {
      this._requestManager = new RequestManager(provider);
      this.currentProvider = provider;
      this.eth = new Eth(this);
      this.db = new DB(this);
      this.shh = new Shh(this);
      this.net = new Net(this);
      this.personal = new Personal(this);
      this.bzz = new Swarm(this);
      this.settings = new Settings();
      this.version = {
        api: version.version
      };
      this.providers = {
        HttpProvider,
        IpcProvider
      };
      this._extend = extend(this);
      this._extend({
        properties: properties()
      });
    }
    Web3.providers = {
      HttpProvider,
      IpcProvider
    };
    Web3.prototype.setProvider = function(provider) {
      this._requestManager.setProvider(provider);
      this.currentProvider = provider;
    };
    Web3.prototype.reset = function(keepIsSyncing) {
      this._requestManager.reset(keepIsSyncing);
      this.settings = new Settings();
    };
    Web3.prototype.BigNumber = BigNumber;
    Web3.prototype.toHex = utils.toHex;
    Web3.prototype.toAscii = utils.toAscii;
    Web3.prototype.toUtf8 = utils.toUtf8;
    Web3.prototype.fromAscii = utils.fromAscii;
    Web3.prototype.fromUtf8 = utils.fromUtf8;
    Web3.prototype.toDecimal = utils.toDecimal;
    Web3.prototype.fromDecimal = utils.fromDecimal;
    Web3.prototype.toBigNumber = utils.toBigNumber;
    Web3.prototype.toWei = utils.toWei;
    Web3.prototype.fromWei = utils.fromWei;
    Web3.prototype.isAddress = utils.isAddress;
    Web3.prototype.isChecksumAddress = utils.isChecksumAddress;
    Web3.prototype.toChecksumAddress = utils.toChecksumAddress;
    Web3.prototype.isIBAN = utils.isIBAN;
    Web3.prototype.padLeft = utils.padLeft;
    Web3.prototype.padRight = utils.padRight;
    Web3.prototype.sha3 = function(string, options) {
      return "0x" + sha3(string, options);
    };
    Web3.prototype.fromICAP = function(icap) {
      var iban = new Iban(icap);
      return iban.address();
    };
    var properties = function() {
      return [
        new Property({
          name: "version.node",
          getter: "web3_clientVersion"
        }),
        new Property({
          name: "version.network",
          getter: "net_version",
          inputFormatter: utils.toDecimal
        }),
        new Property({
          name: "version.ethereum",
          getter: "eth_protocolVersion",
          inputFormatter: utils.toDecimal
        }),
        new Property({
          name: "version.whisper",
          getter: "shh_version",
          inputFormatter: utils.toDecimal
        })
      ];
    };
    Web3.prototype.isConnected = function() {
      return this.currentProvider && this.currentProvider.isConnected();
    };
    Web3.prototype.createBatch = function() {
      return new Batch(this);
    };
    module.exports = Web3;
  }
});

// node_modules/web3/index.js
var require_web32 = __commonJS({
  "node_modules/web3/index.js"(exports, module) {
    var Web3 = require_web3();
    if (typeof window !== "undefined" && typeof window.Web3 === "undefined") {
      window.Web3 = Web3;
    }
    module.exports = Web3;
  }
});
export default require_web32();
/*! Bundled license information:

bignumber.js/bignumber.js:
  (*! bignumber.js v2.0.7 https://github.com/MikeMcl/bignumber.js/LICENCE *)

crypto-js/ripemd160.js:
  (** @preserve
  	(c) 2012 by CÃ©dric Mesnil. All rights reserved.
  
  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  
  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  
  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  	*)

crypto-js/mode-ctr-gladman.js:
  (** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   *)

utf8/utf8.js:
  (*! https://mths.be/utf8js v2.1.2 by @mathias *)

web3/lib/web3.js:
  (*!
   * web3.js - Ethereum JavaScript API
   *
   * @license lgpl-3.0
   * @see https://github.com/ethereum/web3.js
  *)
*/
//# sourceMappingURL=web3.js.map
